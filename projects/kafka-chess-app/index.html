<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Kafka Chess App | Vincent Cheng Yun Sheng </title> <meta name="author" content="Vincent Cheng Yun Sheng"> <meta name="description" content="Building a web-based chess game with real-time analytics"> <meta name="keywords" content="portfolio-website, data-science, data-analytics, ai"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/profile_pic.jpg?e8022a1151687468392a5d02ab42ebdd"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://cyshen11.github.io/projects/kafka-chess-app/"> <script src="/assets/js/theme.js?bd888c560287cd675855c7662a167c4a"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Vincent</span> Cheng Yun Sheng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Kafka Chess App</h1> <p class="post-description">Building a web-based chess game with real-time analytics</p> </header> <article> <p><code class="language-plaintext highlighter-rouge">kafka-chess</code> is a project that builds a <strong>web-based chess game</strong> with <em>real-time analytics</em>. Players interact with an <em>interactive chessboard</em> via a web application, where every move and game event is published to a <em>Kafka event bus</em>. An <em>Apache Flink engine</em> continuously processes these events to calculate live game statistics, which are then displayed on a dynamic <em>Streamlit dashboard</em>.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/kafka-chess-app/chess_app_screenshot-480.webp 480w,/assets/img/kafka-chess-app/chess_app_screenshot-800.webp 800w,/assets/img/kafka-chess-app/chess_app_screenshot-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/kafka-chess-app/chess_app_screenshot.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Interactive Chessboard Screenshot" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Interactive Chessboard</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/kafka-chess-app/analytics_app_screenshot-480.webp 480w,/assets/img/kafka-chess-app/analytics_app_screenshot-800.webp 800w,/assets/img/kafka-chess-app/analytics_app_screenshot-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/kafka-chess-app/analytics_app_screenshot.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Streamlit Dashboard Screenshot" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Streamlit Dashboard</p> <p><strong>Source Repository:</strong> <a href="https://github.com/cyshen11/kafka-chess" rel="external nofollow noopener" target="_blank">https://github.com/cyshen11/kafka-chess</a></p> <pre><code class="language-mermaid">flowchart TD
    A0["Chess Game Engine
"]
    A1["Interactive Chessboard
"]
    A2["Web Application Backend
"]
    A3["Kafka Event Bus
"]
    A4["Flink Analytics Engine
"]
    A5["Streamlit Analytics Dashboard
"]
    A6["Game Interaction Controller
"]
    A7["Live Data Update Workers
"]
    A6 -- "Consults rules" --&gt; A0
    A6 -- "Updates display" --&gt; A1
    A1 -- "Triggers events" --&gt; A6
    A6 -- "Sends game data" --&gt; A2
    A2 -- "Publishes events to" --&gt; A3
    A4 -- "Consumes data from" --&gt; A3
    A4 -- "Provides analytics to" --&gt; A7
    A7 -- "Updates UI of" --&gt; A5
</code></pre> <p><br></p> <h2 id="tech-stack">Tech Stack</h2> <ul> <li>Frontend: Flask, Streamlit</li> <li>Database: Kafka</li> <li>Analytics Engine: Flink</li> </ul> <p><br></p> <h2 id="getting-started">Getting Started</h2> <ol> <li>Clone the source repository: <code class="language-plaintext highlighter-rouge">git clone https://github.com/cyshen11/kafka-chess.git</code>.</li> <li>Create a python environment and install the requirements.txt.</li> <li>Run <code class="language-plaintext highlighter-rouge">flask --app flaskr run --debug</code> to run the interactive chessboard and navigate to 127.0.0.1:5000 to view it.</li> <li>Change directory to Kafka <code class="language-plaintext highlighter-rouge">cd kafka</code> and run <code class="language-plaintext highlighter-rouge">docker compose up</code> to run the Kafka server in Docker container.</li> <li>Change directory to parent level <code class="language-plaintext highlighter-rouge">cd ../</code>.</li> <li>Run <code class="language-plaintext highlighter-rouge">streamlit run streamlit/app.py</code> to run the analytics dashboard and navigate to 127.0.0.1:8501 to view it.</li> </ol> <p><br></p> <h2 id="chapters">Chapters</h2> <ol> <li><a href="#chapter-1-web-application-backend">Web Application Backend </a></li> <li><a href="#chapter-2-interactive-chessboard">Interactive Chessboard </a></li> <li><a href="#chapter-3-streamlit-analytics-dashboard">Streamlit Analytics Dashboard </a></li> <li><a href="#chapter-4-game-interaction-controller">Game Interaction Controller </a></li> <li><a href="#chapter-5-chess-game-engine">Chess Game Engine </a></li> <li><a href="#chapter-6-kafka-event-bus">Kafka Event Bus </a></li> <li><a href="#chapter-7-flink-analytics-engine">Flink Analytics Engine </a></li> <li><a href="#chapter-8-live-data-update-workers">Live Data Update Workers </a></li> </ol> <hr> <p><br></p> <h1 id="chapter-1-web-application-backend">Chapter 1: Web Application Backend</h1> <p>Welcome to <code class="language-plaintext highlighter-rouge">kafka-chess</code>! In this project, we’re building a complete chess game that uses some really powerful tools. Think of it like building a complex machine: it has many different parts, and each part has a specific job.</p> <p>This first chapter introduces you to the <strong>Web Application Backend</strong>. Imagine you’re playing chess on your computer. You open your web browser, and <em>poof!</em> a chessboard appears. You click on a pawn, and it moves. How does all of this happen? That’s exactly what the Web Application Backend helps to manage!</p> <p><br></p> <h2 id="what-is-the-web-application-backend">What is the Web Application Backend?</h2> <p>At its heart, the Web Application Backend is like the <strong>control center</strong> for your entire web experience. It has two main jobs:</p> <ol> <li> <strong>Serving the Webpage:</strong> It’s responsible for showing you the <code class="language-plaintext highlighter-rouge">index.html</code> page, which is where you see the chessboard and all the game controls. Think of it as the restaurant that gives you the menu.</li> <li> <strong>Receiving Your Actions:</strong> When you make a move, click a button, or surrender in the game, your web browser needs a way to tell the “brain” of the application what you did. The backend provides special “API endpoints” (like different phone numbers for different departments) where your browser can send this information.</li> </ol> <p>But it does one more very important thing: it acts like a <strong>post office</strong>. When you make a move, the backend doesn’t try to figure out if it’s a legal move or what the new board position should be. Instead, it simply takes the information about your move and sends it off to a special “mail system” called Kafka. This allows other parts of our chess system to pick up these “letters” (game events) and process them in real-time.</p> <p><br></p> <h3 id="use-case-making-a-chess-move">Use Case: Making a Chess Move</h3> <p>Let’s use a simple example: You, the player, move a pawn on the screen. How does the Web Application Backend help make this happen?</p> <ol> <li>You interact with the chessboard in your browser.</li> <li>Your browser (the “frontend”) tells the backend, “Hey, I just moved a piece from square ‘e2’ to ‘e4’!”</li> <li>The backend receives this message.</li> <li>Instead of processing the move itself, the backend immediately sends this move information into our “mail system” (Kafka) so other components can react to it.</li> </ol> <p>This process ensures that the backend is fast and efficient, simply passing along information to where it needs to go.</p> <p><br></p> <h2 id="how-the-backend-works-simplified">How the Backend Works (Simplified)</h2> <p>Let’s break down how the backend fulfills its role. We use a Python tool called <strong>Flask</strong> to build our web application.</p> <p><br></p> <h3 id="1-showing-you-the-chessboard">1. Showing You the Chessboard</h3> <p>When you visit the website, the backend’s first job is to show you the main chess game page. This is handled by a function that “routes” requests to the correct page.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In flaskr/__init__.py
</span><span class="kn">from</span> <span class="n">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">render_template</span>

<span class="k">def</span> <span class="nf">create_app</span><span class="p">(</span><span class="n">test_config</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">app</span> <span class="o">=</span> <span class="nc">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="n">instance_relative_config</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># ... (other setup code)
</span>
    <span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># This means "when someone visits the main page /"
</span>    <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
        <span class="c1"># This sends the 'index.html' file to the user's browser
</span>        <span class="k">return</span> <span class="nf">render_template</span><span class="p">(</span><span class="sh">"</span><span class="s">index.html</span><span class="sh">"</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="p">{})</span>

    <span class="k">return</span> <span class="n">app</span>
</code></pre></div></div> <p>In this code:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">app = Flask(__name__, ...)</code> creates our web application.</li> <li> <code class="language-plaintext highlighter-rouge">@app.route("/")</code> is like setting up a street sign that says “If you’re looking for the main page, come this way!”</li> <li> <code class="language-plaintext highlighter-rouge">def main():</code> is the function that runs when someone visits that main page.</li> <li> <code class="language-plaintext highlighter-rouge">return render_template("index.html", ...)</code> tells Flask to send the <code class="language-plaintext highlighter-rouge">index.html</code> file (which contains all the HTML, CSS, and JavaScript for our chessboard) to your web browser. This is how you see the game!</li> </ul> <p><br></p> <h3 id="2-setting-up-the-post-office-kafka-producer">2. Setting Up the “Post Office” (Kafka Producer)</h3> <p>Before the backend can send messages to Kafka, it needs a way to connect. This is done by creating a <code class="language-plaintext highlighter-rouge">Producer</code> object, which is like setting up a connection to the main post office.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In flaskr/__init__.py
</span><span class="kn">from</span> <span class="n">confluent_kafka</span> <span class="kn">import</span> <span class="n">Producer</span>

<span class="n">KAFKA_SERVER</span> <span class="o">=</span> <span class="sh">"</span><span class="s">localhost:9092</span><span class="sh">"</span> <span class="c1"># Where our Kafka "post office" is located
</span>
<span class="c1"># Set up connection details for the producer
</span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">bootstrap.servers</span><span class="sh">"</span><span class="p">:</span> <span class="n">KAFKA_SERVER</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">acks</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">all</span><span class="sh">"</span><span class="p">,</span> <span class="c1"># Make sure messages are safely delivered
</span><span class="p">}</span>

<span class="c1"># Create the Producer instance
</span><span class="n">producer</span> <span class="o">=</span> <span class="nc">Producer</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
</code></pre></div></div> <p>Here:</p> <ul> <li>We import <code class="language-plaintext highlighter-rouge">Producer</code> from <code class="language-plaintext highlighter-rouge">confluent_kafka</code>, which is a library that helps Python talk to Kafka.</li> <li> <code class="language-plaintext highlighter-rouge">KAFKA_SERVER</code> tells our producer where to find the Kafka system (usually on <code class="language-plaintext highlighter-rouge">localhost:9092</code> if you’re running it on your own computer).</li> <li> <code class="language-plaintext highlighter-rouge">producer = Producer(config)</code> creates the actual “post office worker” object that will send our messages.</li> </ul> <p><br></p> <h3 id="3-receiving-your-moves-and-sending-them-to-kafka">3. Receiving Your Moves and Sending Them to Kafka</h3> <p>Now, let’s see how the backend receives your move and sends it off.</p> <p>First, on the <strong>frontend</strong> (the JavaScript code running in your web browser), when you make a move, a function is called to send that information to our backend:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified)</span>

<span class="kd">function</span> <span class="nf">createMove</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">lastMove</span> <span class="o">=</span> <span class="nx">game</span><span class="p">.</span><span class="nf">history</span><span class="p">({</span> <span class="na">verbose</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// Get details of the last move</span>
  <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">v4</span><span class="p">();</span> <span class="c1">// Generate a unique ID for this move</span>
  <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">sessionStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">gameId</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span>
                <span class="dl">'</span><span class="s1">Player</span><span class="dl">'</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">Pawn from e2 to e4</span><span class="dl">'</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> <span class="c1">// Example move details</span>
                <span class="nf">toISOStringLocal</span><span class="p">(</span><span class="k">new</span> <span class="nc">Date</span><span class="p">())</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// When the move happened</span>

  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="c1">// Send the move data to the backend's /add_move API endpoint</span>
  <span class="nx">axios</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://127.0.0.1:5000/add_move/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>This JavaScript code uses <code class="language-plaintext highlighter-rouge">axios.post</code> to send an HTTP POST request to our Flask backend. It sends the <code class="language-plaintext highlighter-rouge">key</code> (a unique ID for the move) and <code class="language-plaintext highlighter-rouge">value</code> (details about the move) as part of the web address.</p> <p>Next, on the <strong>backend</strong> side, Flask has another route that is specifically designed to listen for these <code class="language-plaintext highlighter-rouge">add_move</code> requests:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In flaskr/__init__.py (simplified)
</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/add_move/&lt;key&gt;/&lt;value&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">POST</span><span class="sh">"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">add_move</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">topic</span> <span class="o">=</span> <span class="sh">"</span><span class="s">moves</span><span class="sh">"</span> <span class="c1"># We send chess moves to the 'moves' topic
</span>
    <span class="c1"># Use our Kafka producer to send the message
</span>    <span class="n">producer</span><span class="p">.</span><span class="nf">produce</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">on_delivery</span><span class="o">=</span><span class="n">delivery_callback</span><span class="p">)</span>

    <span class="c1"># Make sure the message is sent before continuing
</span>    <span class="n">producer</span><span class="p">.</span><span class="nf">poll</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
    <span class="n">producer</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>

    <span class="k">return</span> <span class="sh">""</span> <span class="c1"># Send an empty response back to the frontend
</span></code></pre></div></div> <p>Here’s what happens step-by-step:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">@app.route("/add_move/&lt;key&gt;/&lt;value&gt;", methods=["POST"])</code> sets up another “street sign.” This one says, “If you’re sending a POST request to <code class="language-plaintext highlighter-rouge">/add_move</code> with a <code class="language-plaintext highlighter-rouge">key</code> and <code class="language-plaintext highlighter-rouge">value</code>, come this way!”</li> <li> <code class="language-plaintext highlighter-rouge">def add_move(key, value):</code> is the function that runs when your browser sends a move. The <code class="language-plaintext highlighter-rouge">key</code> and <code class="language-plaintext highlighter-rouge">value</code> from the browser are passed directly into this function.</li> <li> <code class="language-plaintext highlighter-rouge">topic = "moves"</code>: Kafka uses “topics” to organize messages, like different departments in a post office. All chess moves go into the <code class="language-plaintext highlighter-rouge">moves</code> topic.</li> <li> <code class="language-plaintext highlighter-rouge">producer.produce(topic, value, key, ...)</code> is the crucial line! This tells our “post office worker” (<code class="language-plaintext highlighter-rouge">producer</code>) to send the <code class="language-plaintext highlighter-rouge">value</code> (the move details) to the <code class="language-plaintext highlighter-rouge">topic</code> (<code class="language-plaintext highlighter-rouge">moves</code>), using the <code class="language-plaintext highlighter-rouge">key</code> as an identifier. <code class="language-plaintext highlighter-rouge">on_delivery=delivery_callback</code> is just a way to check if the message was delivered successfully.</li> <li> <code class="language-plaintext highlighter-rouge">producer.poll()</code> and <code class="language-plaintext highlighter-rouge">producer.flush()</code> ensure that the message is actually sent out immediately.</li> </ul> <p>There’s also a similar endpoint, <code class="language-plaintext highlighter-rouge">/add_game</code>, which works in the same way to send information about when a game starts or ends to a different Kafka topic called <code class="language-plaintext highlighter-rouge">games</code>.</p> <p><br></p> <h2 id="internal-workflow">Internal Workflow</h2> <p>Let’s visualize the simplified interaction when you make a move:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Frontend as Interactive Chessboard
    participant Backend as Web Application Backend
    participant Kafka as Kafka Event Bus

    User-&gt;&gt;Frontend: Makes a move (e.g., clicks a square)
    Frontend-&gt;&gt;Backend: Sends move data via HTTP POST to /add_move
    Backend-&gt;&gt;Kafka: Produces 'move' event to 'moves' topic
    Kafka--&gt;&gt;Backend: Confirms event received
    Backend--&gt;&gt;Frontend: Sends empty response (acknowledgment)
</code></pre> <p>In this flow:</p> <ol> <li> <strong>User makes a move:</strong> You interact with the visual chessboard.</li> <li> <strong>Frontend sends move data:</strong> The JavaScript code on your webpage detects the move and uses <code class="language-plaintext highlighter-rouge">axios.post</code> to send the details to the backend’s <code class="language-plaintext highlighter-rouge">/add_move</code> endpoint.</li> <li> <strong>Backend produces event to Kafka:</strong> The <code class="language-plaintext highlighter-rouge">add_move</code> function in Flask receives the move data. It doesn’t process the game logic itself; instead, it uses the <code class="language-plaintext highlighter-rouge">producer</code> to send this raw move information into the “moves” topic within Kafka.</li> <li> <strong>Kafka confirms receipt:</strong> Kafka acknowledges that it has received the message.</li> <li> <strong>Backend responds to Frontend:</strong> The backend sends a simple “OK” (an empty response) back to the frontend, letting the browser know the message was received.</li> </ol> <p>This design makes the backend very lightweight and efficient, as its main job is just to route information quickly!</p> <p><br></p> <h2 id="conclusion">Conclusion</h2> <p>You’ve now learned about the <strong>Web Application Backend</strong>, which is the “control center” that serves our chess webpage, listens for your actions (like making a move), and acts as a “post office” to send these actions to Kafka for further processing. This allows our backend to stay fast and focused on getting information where it needs to go.</p> <p>Next up, we’ll dive into the <a href="02_interactive_chessboard_.md">Interactive Chessboard</a> itself, to see how the web page handles your clicks and displays the game!</p> <hr> <p><br></p> <h1 id="chapter-2-interactive-chessboard">Chapter 2: Interactive Chessboard</h1> <p>Welcome back! In <a href="01_web_application_backend_.md">Chapter 1: Web Application Backend</a>, we learned how our backend serves the <code class="language-plaintext highlighter-rouge">index.html</code> page to your web browser and acts as a “post office” for game events. But once that <code class="language-plaintext highlighter-rouge">index.html</code> page loads, how does the actual chessboard appear? How do you interact with it, dragging and dropping pieces? That’s where the <strong>Interactive Chessboard</strong> comes in!</p> <p><br></p> <h2 id="what-is-the-interactive-chessboard">What is the Interactive Chessboard?</h2> <p>Imagine the chessboard you see on your screen. It’s not just a static image; it’s a dynamic playground where you move pieces around. The <strong>Interactive Chessboard</strong> is the part of our system responsible for making this visual experience possible.</p> <p>Its main jobs are:</p> <ol> <li> <strong>Drawing the Board and Pieces:</strong> It’s like the artist who paints the chessboard, draws all the pawns, knights, and kings, and places them in their starting positions.</li> <li> <strong>Listening to Your Actions:</strong> When you click a square, drag a piece, or tap your screen, the Interactive Chessboard detects these actions.</li> <li> <strong>Translating Actions into Events:</strong> It doesn’t know the rules of chess (like if a knight can jump over pieces). Instead, it’s like a messenger that tells another part of our system, “Hey, the user just tried to move a piece from square ‘e2’ to ‘e4’!”</li> </ol> <p>The <code class="language-plaintext highlighter-rouge">chessboard2.js</code> library is the specific tool we use to create this interactive visual element. It’s the “front-end” part that runs directly in your web browser.</p> <p><br></p> <h3 id="use-case-moving-a-chess-piece-visually">Use Case: Moving a Chess Piece Visually</h3> <p>Let’s use our familiar example: You, the player, want to move a pawn on the screen. How does the Interactive Chessboard make this visual interaction happen?</p> <ol> <li>You drag a pawn from <code class="language-plaintext highlighter-rouge">e2</code> to <code class="language-plaintext highlighter-rouge">e4</code> with your mouse.</li> <li>The <code class="language-plaintext highlighter-rouge">chessboard2.js</code> library detects this “drag and drop” action.</li> <li>It then calls a special function (a “callback”) that <em>we</em> provide, telling it, “A piece was dropped from ‘e2’ to ‘e4’!”</li> <li>Our special function (which lives in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>, covered in a later chapter) then checks if this is a legal move using the <a href="05_chess_game_engine_.md">Chess Game Engine</a>.</li> <li>If it’s legal, our function tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> to update its display to show the pawn now on <code class="language-plaintext highlighter-rouge">e4</code>.</li> </ol> <p>Notice a key point: <code class="language-plaintext highlighter-rouge">chessboard2.js</code> is only concerned with <em>showing</em> things and <em>reporting</em> user interactions. It doesn’t know the game rules itself. It relies on other parts of our system to tell it what to display.</p> <p><br></p> <h2 id="how-the-interactive-chessboard-works-simplified">How the Interactive Chessboard Works (Simplified)</h2> <p>The <code class="language-plaintext highlighter-rouge">chessboard2.js</code> library is initialized and configured directly within your <code class="language-plaintext highlighter-rouge">index.html</code> file, using JavaScript code.</p> <p><br></p> <h3 id="1-setting-up-the-visual-board">1. Setting Up the Visual Board</h3> <p>When the <code class="language-plaintext highlighter-rouge">index.html</code> page loads in your browser, JavaScript code runs to create the chessboard.</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- In flaskr/templates/index.html (simplified) --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"myBoard"</span> <span class="na">style=</span><span class="s">"width: 400px; margin: 20px 0;"</span><span class="nt">&gt;&lt;/div&gt;</span>

<span class="nt">&lt;script&gt;</span>
  <span class="c1">// ... (other setup code)</span>

  <span class="c1">// Chessboard Configuration</span>
  <span class="kd">const</span> <span class="nx">boardConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">draggable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>        <span class="c1">// Allow piece dragging</span>
    <span class="nx">onDragStart</span><span class="p">,</span>           <span class="c1">// Function called when drag starts</span>
    <span class="nx">onTouchSquare</span><span class="p">,</span>         <span class="c1">// Function for touch/click interactions</span>
    <span class="nx">onDrop</span><span class="p">,</span>               <span class="c1">// Function called when piece is dropped</span>
    <span class="nx">onSnapEnd</span><span class="p">,</span>            <span class="c1">// Function called after piece animation ends</span>
    <span class="na">position</span><span class="p">:</span> <span class="nx">game</span><span class="p">.</span><span class="nf">fen</span><span class="p">(),</span> <span class="c1">// Set initial board position from game state</span>
    <span class="na">touchMove</span><span class="p">:</span> <span class="kc">true</span>       <span class="c1">// Enable touch-based moves on mobile</span>
  <span class="p">}</span>
  
  <span class="c1">// Initialize the visual chessboard in the myBoard div</span>
  <span class="kd">const</span> <span class="nx">board</span> <span class="o">=</span> <span class="nc">Chessboard2</span><span class="p">(</span><span class="dl">'</span><span class="s1">myBoard</span><span class="dl">'</span><span class="p">,</span> <span class="nx">boardConfig</span><span class="p">)</span>
  <span class="c1">// ... (more code)</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <p>In this snippet:</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">&lt;div id="myBoard"&gt;&lt;/div&gt;</code> is a placeholder on your webpage where the chessboard will be drawn.</li> <li> <code class="language-plaintext highlighter-rouge">boardConfig</code> is an object (like a shopping list) that tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> how we want our board to behave. <ul> <li> <code class="language-plaintext highlighter-rouge">draggable: true</code> means you can pick up pieces.</li> <li> <code class="language-plaintext highlighter-rouge">position: game.fen()</code> tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> the current state of the game board using a special code called FEN (which the <a href="05_chess_game_engine_.md">Chess Game Engine</a> understands).</li> <li> <code class="language-plaintext highlighter-rouge">onDragStart</code>, <code class="language-plaintext highlighter-rouge">onTouchSquare</code>, <code class="language-plaintext highlighter-rouge">onDrop</code>, and <code class="language-plaintext highlighter-rouge">onSnapEnd</code> are <strong>callback functions</strong>. These are functions <em>we write</em> in another file (<code class="language-plaintext highlighter-rouge">chess_actions.js</code>, as you’ll see in <a href="04_game_interaction_controller_.md">Chapter 4: Game Interaction Controller</a>). <code class="language-plaintext highlighter-rouge">chessboard2.js</code> will call these functions when a user performs a specific action (like starting a drag or dropping a piece).</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">const board = Chessboard2('myBoard', boardConfig)</code> is the line that actually creates the chessboard! It tells the <code class="language-plaintext highlighter-rouge">chessboard2.js</code> library: “Hey, draw a chessboard inside the <code class="language-plaintext highlighter-rouge">div</code> with the ID ‘myBoard’, and use these <code class="language-plaintext highlighter-rouge">boardConfig</code> settings.”</li> </ul> <p><br></p> <h3 id="2-reacting-to-your-visual-moves">2. Reacting to Your Visual Moves</h3> <p>When you drag and drop a piece, <code class="language-plaintext highlighter-rouge">chessboard2.js</code> doesn’t know if it’s a legal chess move. It just reports the action. It calls the <code class="language-plaintext highlighter-rouge">onDrop</code> function (which we defined in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>).</p> <p>Let’s look at a simplified <code class="language-plaintext highlighter-rouge">onDrop</code> function:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified)</span>

<span class="kd">function</span> <span class="nf">onDrop</span> <span class="p">(</span><span class="nx">dropEvt</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. Try to make the move using the Chess Game Engine (chess.js)</span>
  <span class="kd">const</span> <span class="nx">move</span> <span class="o">=</span> <span class="nx">game</span><span class="p">.</span><span class="nf">move</span><span class="p">({</span>
    <span class="na">from</span><span class="p">:</span> <span class="nx">dropEvt</span><span class="p">.</span><span class="nx">source</span><span class="p">,</span> <span class="c1">// Where the piece came from (e.g., 'e2')</span>
    <span class="na">to</span><span class="p">:</span> <span class="nx">dropEvt</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span>   <span class="c1">// Where the piece was dropped (e.g., 'e4')</span>
    <span class="na">promotion</span><span class="p">:</span> <span class="dl">'</span><span class="s1">q</span><span class="dl">'</span>        <span class="c1">// (simplified) always promote to a Queen</span>
  <span class="p">})</span>

  <span class="c1">// 2. If the move was legal (chess.js returned a result)</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">move</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 3. Tell chessboard2.js to update its visual position</span>
    <span class="nx">board</span><span class="p">.</span><span class="nf">position</span><span class="p">(</span><span class="nx">game</span><span class="p">.</span><span class="nf">fen</span><span class="p">()).</span><span class="nf">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 4. Update other game elements (like move history)</span>
      <span class="nf">updatePGN</span><span class="p">()</span>
      <span class="nf">updateStatus</span><span class="p">()</span>

      <span class="c1">// 5. (Later chapters) send move to backend for Kafka</span>
      <span class="nf">createMove</span><span class="p">()</span> <span class="c1">// Sends move to Flask backend (Chapter 1)</span>
      
      <span class="c1">// Make a random move for the AI (for single-player demo)</span>
      <span class="nb">window</span><span class="p">.</span><span class="nf">setTimeout</span><span class="p">(</span><span class="nx">makeRandomMove</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// If the move was illegal, snap the piece back to its original square</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">snapback</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this code:</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">onDrop</code> function receives <code class="language-plaintext highlighter-rouge">dropEvt</code> (an event object) from <code class="language-plaintext highlighter-rouge">chessboard2.js</code>. This object contains <code class="language-plaintext highlighter-rouge">source</code> (the starting square) and <code class="language-plaintext highlighter-rouge">target</code> (the ending square).</li> <li> <code class="language-plaintext highlighter-rouge">game.move(...)</code> is a function from the <a href="05_chess_game_engine_.md">Chess Game Engine</a> (<code class="language-plaintext highlighter-rouge">chess.js</code>). This is where the <em>actual chess rules</em> are checked.</li> <li>If <code class="language-plaintext highlighter-rouge">game.move()</code> returns a valid <code class="language-plaintext highlighter-rouge">move</code> (meaning the move was legal), then: <ul> <li> <code class="language-plaintext highlighter-rouge">board.position(game.fen())</code> tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> to redraw the board to the <em>new</em> game state (provided by <code class="language-plaintext highlighter-rouge">game.fen()</code>). This visually updates the board.</li> <li> <code class="language-plaintext highlighter-rouge">updatePGN()</code> and <code class="language-plaintext highlighter-rouge">updateStatus()</code> update the text you see on the page.</li> <li> <code class="language-plaintext highlighter-rouge">createMove()</code> (as we saw in <a href="01_web_application_backend_.md">Chapter 1: Web Application Backend</a>) sends the move data to our Flask backend, which then pushes it to Kafka.</li> </ul> </li> </ul> <p><br></p> <h2 id="internal-workflow-1">Internal Workflow</h2> <p>Let’s visualize the steps involved when you interact with the chessboard:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant A as Interactive Chessboard (chessboard2.js)
    participant B as Game Interaction Controller (chess_actions.js)
    participant C as Chess Game Engine (chess.js)

    User-&gt;&gt;A: Drags a piece from e2 to e4
    A-&gt;&gt;B: Calls onDrop(source: 'e2', target: 'e4')
    B-&gt;&gt;C: Calls game.move({from: 'e2', to: 'e4'})
    C--&gt;&gt;B: Returns move object (if legal)
    B-&gt;&gt;A: Calls board.position(game.fen())
    A--&gt;&gt;User: Visually updates board
</code></pre> <p>In this flow:</p> <ol> <li> <strong>User Interacts:</strong> You physically drag a chess piece on the screen.</li> <li> <strong>Interactive Chessboard Detects:</strong> <code class="language-plaintext highlighter-rouge">chessboard2.js</code> detects this interaction and figures out which squares were involved.</li> <li> <strong>Calls Callback:</strong> <code class="language-plaintext highlighter-rouge">chessboard2.js</code> calls the <code class="language-plaintext highlighter-rouge">onDrop</code> function, passing details of the move attempt.</li> <li> <strong>Game Logic:</strong> The <code class="language-plaintext highlighter-rouge">onDrop</code> function (in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>) uses the <code class="language-plaintext highlighter-rouge">game</code> object (from <code class="language-plaintext highlighter-rouge">chess.js</code>) to check if the move is legal and to update the actual game state.</li> <li> <strong>Visual Update:</strong> If the move is valid, the <code class="language-plaintext highlighter-rouge">onDrop</code> function tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> to update its visual display to reflect the new board position.</li> </ol> <p>This separation of concerns is powerful: <code class="language-plaintext highlighter-rouge">chessboard2.js</code> focuses on the “graphics” and user input, while <code class="language-plaintext highlighter-rouge">chess.js</code> handles the “brain” (game rules). Our <code class="language-plaintext highlighter-rouge">chess_actions.js</code> acts as the bridge between them, as you’ll learn more about in <a href="04_game_interaction_controller_.md">Chapter 4: Game Interaction Controller</a>.</p> <p><br></p> <h2 id="conclusion-1">Conclusion</h2> <p>You’ve now seen how the <strong>Interactive Chessboard</strong> (powered by <code class="language-plaintext highlighter-rouge">chessboard2.js</code>) provides the visual interface for our chess game. It handles drawing the board and pieces, and, crucially, it acts as the primary listener for your interactions, passing those “events” to our custom JavaScript functions. This allows us to keep the visual display separate from the actual game logic.</p> <p>Next up, we’ll shift gears and look at how we visualize and analyze game data using a tool called <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>.</p> <hr> <p><br></p> <h1 id="chapter-3-streamlit-analytics-dashboard">Chapter 3: Streamlit Analytics Dashboard</h1> <p>Welcome back! In <a href="01_web_application_backend_.md">Chapter 1: Web Application Backend</a>, we learned how our chess system handles sending messages about moves to Kafka. Then, in <a href="02_interactive_chessboard_.md">Chapter 2: Interactive Chessboard</a>, we saw how the chessboard appears in your browser and lets you interact with it.</p> <p>Now, imagine we have many people playing chess on our platform. We’re collecting all these moves and game starts/ends. But how can we <em>see</em> what’s happening across all games? How many games are active right now? What are the most recent moves being played? We need a way to <strong>display and understand</strong> this information easily.</p> <p><br></p> <h2 id="what-is-the-streamlit-analytics-dashboard">What is the Streamlit Analytics Dashboard?</h2> <p>The <strong>Streamlit Analytics Dashboard</strong> is like a “control panel” or a “TV screen” for our <code class="language-plaintext highlighter-rouge">kafka-chess</code> project. Its main job is to <strong>show you the important numbers and recent activities</strong> from all the chess games being played. Instead of just playing a single game, this dashboard lets you observe the bigger picture.</p> <p>It acts as the <strong>main user interface for observing game trends</strong>. It uses a tool called <strong>Streamlit</strong> to create a web-based dashboard that is visually organized to present game statistics and a live feed of recent moves. This makes insights from our data (which is processed by the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a>, covered later) accessible and easy to understand.</p> <p><br></p> <h3 id="use-case-monitoring-live-chess-game-trends">Use Case: Monitoring Live Chess Game Trends</h3> <p>Let’s say you’re the person running the <code class="language-plaintext highlighter-rouge">kafka-chess</code> platform, or just a curious user. You want to quickly answer questions like:</p> <ul> <li>How many chess games are currently happening?</li> <li>How many total players have joined?</li> <li>What were the last few moves made across <em>any</em> game?</li> </ul> <p>The Streamlit Analytics Dashboard solves this by providing a simple webpage that constantly updates with these answers.</p> <p><br></p> <h2 id="how-the-dashboard-works-simplified">How the Dashboard Works (Simplified)</h2> <p>The core of our dashboard is the <code class="language-plaintext highlighter-rouge">app.py</code> script located in the <code class="language-plaintext highlighter-rouge">streamlit</code> directory. This script uses the Streamlit library to build a webpage that looks nice and shows data.</p> <p><br></p> <h3 id="1-setting-up-the-web-page-layout">1. Setting Up the Web Page Layout</h3> <p>First, <code class="language-plaintext highlighter-rouge">app.py</code> tells Streamlit how the web page should look. It sets a title and divides the page into sections, like arranging furniture in a room.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/app.py (simplified)
</span><span class="kn">import</span> <span class="n">streamlit</span> <span class="k">as</span> <span class="n">st</span>

<span class="c1"># Configure the Streamlit page layout and metadata
</span><span class="n">st</span><span class="p">.</span><span class="nf">set_page_config</span><span class="p">(</span><span class="n">page_title</span><span class="o">=</span><span class="sh">"</span><span class="s">Chess Analytics</span><span class="sh">"</span><span class="p">,</span> <span class="n">page_icon</span><span class="o">=</span><span class="sh">"</span><span class="s">♟️</span><span class="sh">"</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="sh">"</span><span class="s">wide</span><span class="sh">"</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">♟️ Chess Web App Analytics</span><span class="sh">"</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">"</span><span class="s">Built with Streamlit and PyFlink</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Create main content columns - col1 for stats, col2 for moves
</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="nf">columns</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">col1</span><span class="p">.</span><span class="nf">subheader</span><span class="p">(</span><span class="sh">"</span><span class="s">📊 Game Statistics</span><span class="sh">"</span><span class="p">)</span>
<span class="n">col2</span><span class="p">.</span><span class="nf">subheader</span><span class="p">(</span><span class="sh">"</span><span class="s">🔄 Recent Moves</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># ... (more code for data workers)
</span></code></pre></div></div> <p>In this code:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">import streamlit as st</code> brings in the Streamlit library.</li> <li> <code class="language-plaintext highlighter-rouge">st.set_page_config(...)</code> sets up basic things like the tab title in your browser and the overall layout.</li> <li> <code class="language-plaintext highlighter-rouge">st.title(...)</code> puts a big title at the top of our page.</li> <li> <code class="language-plaintext highlighter-rouge">st.columns([1, 2])</code> is a powerful command! It creates two “columns” on our webpage. The <code class="language-plaintext highlighter-rouge">[1, 2]</code> means the second column (<code class="language-plaintext highlighter-rouge">col2</code>) will be twice as wide as the first (<code class="language-plaintext highlighter-rouge">col1</code>). We then give each column its own subheader (<code class="language-plaintext highlighter-rouge">col1.subheader</code>, <code class="language-plaintext highlighter-rouge">col2.subheader</code>) to label its content.</li> </ul> <p><br></p> <h3 id="2-getting-and-displaying-live-data">2. Getting and Displaying Live Data</h3> <p>The dashboard needs to constantly update with new information. It doesn’t just show a static picture; it’s like a live news feed. To do this, we have special “worker threads” (imagine them as small, independent reporters) that constantly fetch data and update specific parts of the dashboard.</p> <p>The <code class="language-plaintext highlighter-rouge">app.py</code> script starts these workers:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/app.py (simplified)
</span><span class="kn">from</span> <span class="n">utils.utils_table_env</span> <span class="kn">import</span> <span class="n">TableEnvCustomized</span>
<span class="kn">from</span> <span class="n">utils.utils_worker</span> <span class="kn">import</span> <span class="n">run_workers</span>

<span class="c1"># ... (page layout code)
</span>
<span class="c1"># Initialize PyFlink table environment for data processing
</span><span class="n">table_env</span> <span class="o">=</span> <span class="nc">TableEnvCustomized</span><span class="p">()</span>
<span class="n">table_env</span><span class="p">.</span><span class="nf">create_source_tables</span><span class="p">()</span> <span class="c1"># Set up connections to data sources
</span>
<span class="c1"># Start the data processing workers
</span><span class="k">try</span><span class="p">:</span>
    <span class="nf">run_workers</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col3</span><span class="p">,</span> <span class="n">col4</span><span class="p">,</span> <span class="n">table_env</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
    <span class="n">st</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">Unable to fetch live data.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">TableEnvCustomized()</code> is setting up the connection to our data processing engine (<a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a>). Think of <code class="language-plaintext highlighter-rouge">TableEnvCustomized()</code> as the “data manager” that knows how to ask for processed game information.</li> <li> <code class="language-plaintext highlighter-rouge">run_workers(...)</code> is the key function that kicks off all our “reporter” threads. It tells them which “column” on the Streamlit page they should update (<code class="language-plaintext highlighter-rouge">col1</code>, <code class="language-plaintext highlighter-rouge">col2</code>, etc.) and gives them the <code class="language-plaintext highlighter-rouge">table_env</code> so they can ask for data.</li> </ul> <p><br></p> <h2 id="internal-workflow-2">Internal Workflow</h2> <p>Let’s visualize how the dashboard gets and displays its live information:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant A as Streamlit App (app.py)
    participant B as Worker Threads (utils_worker.py)
    participant C as Table Environment (Flink Engine)

    User-&gt;&gt;A: Opens Streamlit Dashboard
    A-&gt;&gt;B: Starts Worker Threads (e.g., for stats, for moves)
    loop Continuous Updates
        B-&gt;&gt;C: Worker asks for latest "Game Stats"
        C--&gt;&gt;B: Provides "Active Games", "Completed Games"
        B-&gt;&gt;A: Worker updates `col1` with metrics (st.metric)
        B-&gt;&gt;C: Worker asks for latest "Recent Moves"
        C--&gt;&gt;B: Provides table of recent moves
        B-&gt;&gt;A: Worker updates `col2` with data table (st.dataframe)
    end
</code></pre> <p>In this flow:</p> <ol> <li> <strong>User Opens Dashboard:</strong> You navigate to the Streamlit app in your web browser.</li> <li> <strong>Streamlit App Starts Workers:</strong> The <code class="language-plaintext highlighter-rouge">app.py</code> script runs, sets up the page, and then calls <code class="language-plaintext highlighter-rouge">run_workers</code> to start background tasks.</li> <li> <strong>Workers Request Data:</strong> These “worker threads” (defined in <code class="language-plaintext highlighter-rouge">utils_worker.py</code>) constantly ask the <code class="language-plaintext highlighter-rouge">Table Environment</code> (which represents the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a>’s processed data) for the latest statistics or recent moves.</li> <li> <strong>Flink Provides Data:</strong> The <code class="language-plaintext highlighter-rouge">Table Environment</code> sends back the processed data (e.g., “3 active games,” “a list of 5 recent moves”).</li> <li> <strong>Workers Update Dashboard:</strong> Each worker then takes its data and uses Streamlit commands (<code class="language-plaintext highlighter-rouge">st.metric</code>, <code class="language-plaintext highlighter-rouge">st.dataframe</code>) to update the specific sections of the web page it’s responsible for. This happens continuously, giving you a live view!</li> </ol> <p><br></p> <h3 id="diving-into-the-worker-code">Diving into the Worker Code</h3> <p>Let’s look at a simplified example of one of these “reporter” worker threads from <code class="language-plaintext highlighter-rouge">streamlit/utils/utils_worker.py</code>.</p> <p>Here’s <code class="language-plaintext highlighter-rouge">WorkerThread1</code>, which handles displaying game statistics:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_worker.py (simplified)
</span><span class="kn">import</span> <span class="n">streamlit</span> <span class="k">as</span> <span class="n">st</span>
<span class="kn">from</span> <span class="n">threading</span> <span class="kn">import</span> <span class="n">Thread</span> <span class="c1"># For running tasks in the background
</span>
<span class="k">class</span> <span class="nc">WorkerThread1</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Worker thread for displaying game statistics metrics.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">table_env</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="c1"># This is a Streamlit column (e.g., col1)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span> <span class="o">=</span> <span class="n">table_env</span> <span class="c1"># Our data manager
</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Execute the worker thread to display game statistics.</span><span class="sh">"""</span>
        <span class="c1"># Initial delay to let other things start
</span>        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">delay</span><span class="p">)</span>

        <span class="c1"># Ask the data manager for the game stats stream
</span>        <span class="n">stream</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">get_games_stats</span><span class="p">()</span>

        <span class="c1"># Loop forever, getting new data as it comes in
</span>        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="c1"># Use the target column to display the data
</span>            <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">container</span><span class="p">():</span>
                <span class="c1"># Display metrics like "Active Games"
</span>                <span class="n">st</span><span class="p">.</span><span class="nf">metric</span><span class="p">(</span><span class="sh">"</span><span class="s">Active Games</span><span class="sh">"</span><span class="p">,</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">st</span><span class="p">.</span><span class="nf">metric</span><span class="p">(</span><span class="sh">"</span><span class="s">Games Completed Today</span><span class="sh">"</span><span class="p">,</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <p>Explanation:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">class WorkerThread1(Thread):</code> means this is a special kind of task that can run in the background without freezing the rest of our app.</li> <li> <code class="language-plaintext highlighter-rouge">self.target</code> is the <code class="language-plaintext highlighter-rouge">col1</code> (or similar) Streamlit object we passed to it.</li> <li> <code class="language-plaintext highlighter-rouge">self.table_env.get_games_stats()</code> is where this worker asks the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> for the live game statistics.</li> <li> <code class="language-plaintext highlighter-rouge">for chunk in stream:</code> This loop is crucial! It continuously waits for <em>new</em> data to arrive from Flink. As soon as Flink sends updated stats, this loop gets a <code class="language-plaintext highlighter-rouge">chunk</code> of data.</li> <li> <code class="language-plaintext highlighter-rouge">with self.target.container():</code> ensures that whatever we display (<code class="language-plaintext highlighter-rouge">st.metric</code>) appears inside the specific column (<code class="language-plaintext highlighter-rouge">col1</code>) assigned to this worker.</li> <li> <code class="language-plaintext highlighter-rouge">st.metric("Active Games", chunk[0])</code> displays a nice, big number (a “metric”) labeled “Active Games” using the first piece of data (<code class="language-plaintext highlighter-rouge">chunk[0]</code>) from Flink.</li> </ul> <p>Similarly, <code class="language-plaintext highlighter-rouge">WorkerThread2</code> is responsible for showing the “Recent Moves” table:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_worker.py (simplified)
# ... (imports and other worker classes)
</span>
<span class="k">class</span> <span class="nc">WorkerThread2</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Worker thread for displaying chess moves data table.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">table_env</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span> <span class="o">=</span> <span class="n">table_env</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Execute the worker thread to display moves data.</span><span class="sh">"""</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">delay</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">get_moves</span><span class="p">()</span> <span class="c1"># Get stream of recent moves
</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="c1"># Display moves data as a scrollable dataframe
</span>            <span class="n">self</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">container</span><span class="p">().</span><span class="nf">dataframe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">self.table_env.get_moves()</code> asks Flink for the list of recent moves.</li> <li> <code class="language-plaintext highlighter-rouge">self.target.container().dataframe(chunk, height=400)</code> takes the received <code class="language-plaintext highlighter-rouge">chunk</code> (which is a table of move data) and displays it nicely as a scrollable table within <code class="language-plaintext highlighter-rouge">col2</code> on the dashboard.</li> </ul> <p>Finally, the <code class="language-plaintext highlighter-rouge">run_workers</code> function brings it all together:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_worker.py (simplified)
# ... (worker classes)
</span><span class="kn">from</span> <span class="n">streamlit.runtime.scriptrunner_utils.script_run_context</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_script_run_ctx</span><span class="p">,</span> <span class="n">get_script_run_ctx</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">def</span> <span class="nf">run_workers</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col3</span><span class="p">,</span> <span class="n">col4</span><span class="p">,</span> <span class="n">table_env</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Initialize and start all worker threads for the Streamlit dashboard.</span><span class="sh">"""</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nc">WorkerThread1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">col1</span><span class="p">.</span><span class="nf">empty</span><span class="p">(),</span> <span class="n">table_env</span><span class="p">),</span> <span class="c1"># Stats worker for col1
</span>        <span class="nc">WorkerThread2</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">col2</span><span class="p">.</span><span class="nf">empty</span><span class="p">(),</span> <span class="n">table_env</span><span class="p">),</span> <span class="c1"># Moves worker for col2
</span>        <span class="c1"># WorkerThread3 (disabled for now)
</span>        <span class="nc">WorkerThread4</span><span class="p">(</span><span class="mf">1.3</span><span class="p">,</span> <span class="n">col4</span><span class="p">.</span><span class="nf">empty</span><span class="p">()),</span>           <span class="c1"># Timestamp worker for col4
</span>    <span class="p">]</span>

    <span class="c1"># Start all threads
</span>    <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
        <span class="c1"># Crucial: this allows threads to update the Streamlit page
</span>        <span class="nf">add_script_run_ctx</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="nf">get_script_run_ctx</span><span class="p">())</span>
        <span class="n">thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="c1"># Wait for all threads to complete (they run forever in this case)
</span>    <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
        <span class="n">thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre></div></div> <p>This <code class="language-plaintext highlighter-rouge">run_workers</code> function:</p> <ul> <li>Creates instances of our <code class="language-plaintext highlighter-rouge">WorkerThread</code> reporters, giving them their specific <code class="language-plaintext highlighter-rouge">col</code> (where to display) and <code class="language-plaintext highlighter-rouge">table_env</code> (where to get data). <code class="language-plaintext highlighter-rouge">col1.empty()</code> creates a placeholder in that column that the worker can continuously update.</li> <li>The <code class="language-plaintext highlighter-rouge">add_script_run_ctx(...)</code> line is important technical glue for Streamlit: it tells Streamlit that these background threads are allowed to update the web page. Without it, Streamlit wouldn’t let the threads change what’s on the screen.</li> <li> <code class="language-plaintext highlighter-rouge">thread.start()</code> actually starts each reporter thread running in the background.</li> <li> <code class="language-plaintext highlighter-rouge">thread.join()</code> makes the main program wait for these threads, effectively keeping the dashboard running.</li> </ul> <p><br></p> <h2 id="conclusion-2">Conclusion</h2> <p>You’ve now learned about the <strong>Streamlit Analytics Dashboard</strong>. It’s our real-time “control panel” built with Streamlit, showing live statistics and recent moves from our chess games. We saw how <code class="language-plaintext highlighter-rouge">app.py</code> sets up the page layout, and how “worker threads” in <code class="language-plaintext highlighter-rouge">utils_worker.py</code> continuously fetch processed data from the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> to keep the dashboard updated. This provides a clear, visual way to understand what’s happening across our <code class="language-plaintext highlighter-rouge">kafka-chess</code> system.</p> <p>Next, we’ll dive into the <a href="04_game_interaction_controller_.md">Game Interaction Controller</a>, which acts as the “middleman” between your clicks on the chessboard and the game’s core logic.</p> <hr> <p><br></p> <h1 id="chapter-4-game-interaction-controller">Chapter 4: Game Interaction Controller</h1> <p>Welcome back! In <a href="02_interactive_chessboard_.md">Chapter 2: Interactive Chessboard</a>, we explored how the <code class="language-plaintext highlighter-rouge">chessboard2.js</code> library draws the board and lets you click or drag pieces. We also touched on how it sends signals (like <code class="language-plaintext highlighter-rouge">onDrop</code> or <code class="language-plaintext highlighter-rouge">onTouchSquare</code>) when you interact. Then, in <a href="01_web_application_backend_.md">Chapter 1: Web Application Backend</a>, we learned how our Flask backend acts as a “post office,” ready to receive these game events and send them to Kafka.</p> <p>But there’s a missing piece! When you drag a piece on the visual board, how does the system know if it’s a <em>legal</em> chess move? And if it is, how does that legal move get communicated to the backend to be sent to Kafka?</p> <p>This is where the <strong>Game Interaction Controller</strong> comes in! Think of it as the “player’s assistant” or the “traffic cop” for your chess moves.</p> <p><br></p> <h2 id="what-is-the-game-interaction-controller">What is the Game Interaction Controller?</h2> <p>The Game Interaction Controller (GIC) is like the <strong>central coordinator</strong> for your live chess game. It’s not the one drawing the board, and it doesn’t know all the chess rules by itself. Instead, its main jobs are:</p> <ol> <li> <strong>Interpreting Your Actions:</strong> It receives raw interactions from the visual chessboard (like “piece moved from E2 to E4”).</li> <li> <strong>Consulting the Rulebook:</strong> It asks the real chess “brain” (the <a href="05_chess_game_engine_.md">Chess Game Engine</a>) if your proposed move is legal.</li> <li> <strong>Updating the World:</strong> If the move is legal, it tells the visual chessboard to update its display, updates other parts of the game (like showing “checkmate!”), and, crucially, tells the <a href="01_web_application_backend_.md">Web Application Backend</a> to send the move information to Kafka.</li> </ol> <p>The <code class="language-plaintext highlighter-rouge">chess_actions.js</code> file is where this “assistant” lives. It’s a JavaScript file that connects all the pieces of our frontend chess game.</p> <p><br></p> <h3 id="use-case-making-a-valid-chess-move">Use Case: Making a Valid Chess Move</h3> <p>Let’s use our familiar example: You, the player, try to move a pawn from <code class="language-plaintext highlighter-rouge">e2</code> to <code class="language-plaintext highlighter-rouge">e4</code>. How does the Game Interaction Controller manage this?</p> <ol> <li>You drag the pawn visually on the board.</li> <li>The <a href="02_interactive_chessboard_.md">Interactive Chessboard</a> (<code class="language-plaintext highlighter-rouge">chessboard2.js</code>) detects this and calls the <code class="language-plaintext highlighter-rouge">onDrop</code> function (which is part of our Game Interaction Controller in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>).</li> <li>The Game Interaction Controller takes the <code class="language-plaintext highlighter-rouge">e2</code> and <code class="language-plaintext highlighter-rouge">e4</code> information and asks the <a href="05_chess_game_engine_.md">Chess Game Engine</a> (<code class="language-plaintext highlighter-rouge">chess.js</code>), “Is moving a pawn from <code class="language-plaintext highlighter-rouge">e2</code> to <code class="language-plaintext highlighter-rouge">e4</code> a legal move right now?”</li> <li>The <a href="05_chess_game_engine_.md">Chess Game Engine</a> checks its rules and says, “Yes, that’s a legal move!”</li> <li>The Game Interaction Controller then: <ul> <li>Tells the visual board (<code class="language-plaintext highlighter-rouge">chessboard2.js</code>) to <em>permanently</em> show the pawn on <code class="language-plaintext highlighter-rouge">e4</code>.</li> <li>Updates the text on the screen (like “White to move” or “Check!”).</li> <li>Tells the <a href="01_web_application_backend_.md">Web Application Backend</a> to record this move by sending it to Kafka.</li> </ul> </li> </ol> <p>If the move wasn’t legal (e.g., trying to move a pawn sideways), the Game Interaction Controller would tell the visual board to “snap back” the piece to its original square.</p> <p><br></p> <h2 id="how-the-game-interaction-controller-works-simplified">How the Game Interaction Controller Works (Simplified)</h2> <p>The <code class="language-plaintext highlighter-rouge">chess_actions.js</code> file contains various functions that act as the Game Interaction Controller. These functions are often “callback” functions that the <code class="language-plaintext highlighter-rouge">chessboard2.js</code> library calls when a user interacts.</p> <p><br></p> <h3 id="1-connecting-to-the-chess-brain-and-visual-board">1. Connecting to the “Chess Brain” and “Visual Board”</h3> <p>At the very start of our <code class="language-plaintext highlighter-rouge">index.html</code> file, we initialize the <code class="language-plaintext highlighter-rouge">Chess</code> game object and the <code class="language-plaintext highlighter-rouge">Chessboard2</code> visual board:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/templates/index.html (inside &lt;script&gt; tags)</span>

<span class="c1">// Create new chess game instance using chess.js library</span>
<span class="kd">const</span> <span class="nx">game</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Chess</span><span class="p">();</span> <span class="c1">// This is our Chess Game Engine!</span>

<span class="c1">// Chessboard Configuration</span>
<span class="kd">const</span> <span class="nx">boardConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">draggable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>        <span class="c1">// Allow piece dragging</span>
  <span class="nx">onDragStart</span><span class="p">,</span>           <span class="c1">// Function called when drag starts</span>
  <span class="nx">onDrop</span><span class="p">,</span>               <span class="c1">// Function called when piece is dropped</span>
  <span class="c1">// ... other callbacks</span>
<span class="p">}</span>

<span class="c1">// Initialize the visual chessboard</span>
<span class="kd">const</span> <span class="nx">board</span> <span class="o">=</span> <span class="nc">Chessboard2</span><span class="p">(</span><span class="dl">'</span><span class="s1">myBoard</span><span class="dl">'</span><span class="p">,</span> <span class="nx">boardConfig</span><span class="p">)</span> <span class="c1">// This is our Interactive Chessboard!</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">const game = new Chess();</code> creates an object that understands all the rules of chess. This is our direct link to the <a href="05_chess_game_engine_.md">Chess Game Engine</a>.</li> <li> <code class="language-plaintext highlighter-rouge">const board = Chessboard2('myBoard', boardConfig)</code> creates the visual board. Notice <code class="language-plaintext highlighter-rouge">onDragStart</code> and <code class="language-plaintext highlighter-rouge">onDrop</code> are listed in <code class="language-plaintext highlighter-rouge">boardConfig</code>. These tell <code class="language-plaintext highlighter-rouge">chessboard2.js</code> <em>which functions to call</em> in <code class="language-plaintext highlighter-rouge">chess_actions.js</code> when the user drags or drops a piece. The <code class="language-plaintext highlighter-rouge">board</code> object also has functions like <code class="language-plaintext highlighter-rouge">board.position()</code> that the GIC will use to update the visual board.</li> </ul> <p><br></p> <h3 id="2-processing-a-drag-and-drop-move-ondrop">2. Processing a Drag-and-Drop Move (<code class="language-plaintext highlighter-rouge">onDrop</code>)</h3> <p>When you drag a piece and drop it, <code class="language-plaintext highlighter-rouge">chessboard2.js</code> calls the <code class="language-plaintext highlighter-rouge">onDrop</code> function in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified)</span>

<span class="kd">function</span> <span class="nf">onDrop</span> <span class="p">(</span><span class="nx">dropEvt</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. Try to make the move using the Chess Game Engine (chess.js)</span>
  <span class="kd">const</span> <span class="nx">move</span> <span class="o">=</span> <span class="nx">game</span><span class="p">.</span><span class="nf">move</span><span class="p">({</span>
    <span class="na">from</span><span class="p">:</span> <span class="nx">dropEvt</span><span class="p">.</span><span class="nx">source</span><span class="p">,</span> <span class="c1">// Where the piece came from (e.g., 'e2')</span>
    <span class="na">to</span><span class="p">:</span> <span class="nx">dropEvt</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span>   <span class="c1">// Where the piece was dropped (e.g., 'e4')</span>
    <span class="na">promotion</span><span class="p">:</span> <span class="dl">'</span><span class="s1">q</span><span class="dl">'</span>        <span class="c1">// (for simplicity) always promote to a Queen</span>
  <span class="p">})</span>

  <span class="c1">// 2. If the move was legal (chess.js returned a result)</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">move</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 3. Tell chessboard2.js to update its visual position</span>
    <span class="nx">board</span><span class="p">.</span><span class="nf">position</span><span class="p">(</span><span class="nx">game</span><span class="p">.</span><span class="nf">fen</span><span class="p">()).</span><span class="nf">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 4. Update other game elements (like move history &amp; status)</span>
      <span class="nf">updatePGN</span><span class="p">()</span>
      <span class="nf">updateStatus</span><span class="p">()</span>

      <span class="c1">// 5. Send the valid move to the backend for Kafka</span>
      <span class="nf">createMove</span><span class="p">()</span> <span class="c1">// Sends move to Flask backend (Chapter 1)</span>
      
      <span class="c1">// Make AI move (for demo purposes)</span>
      <span class="nb">window</span><span class="p">.</span><span class="nf">setTimeout</span><span class="p">(</span><span class="nx">makeRandomMove</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// If the move was illegal, snap the piece back to its original square</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">snapback</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s break down this simplified <code class="language-plaintext highlighter-rouge">onDrop</code> function:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">function onDrop (dropEvt)</code>: This function is called by <code class="language-plaintext highlighter-rouge">chessboard2.js</code>. It receives <code class="language-plaintext highlighter-rouge">dropEvt</code>, which contains details like <code class="language-plaintext highlighter-rouge">dropEvt.source</code> (the starting square like ‘e2’) and <code class="language-plaintext highlighter-rouge">dropEvt.target</code> (the ending square like ‘e4’).</li> <li> <code class="language-plaintext highlighter-rouge">game.move(...)</code>: This is the crucial line! It asks the <a href="05_chess_game_engine_.md">Chess Game Engine</a> (<code class="language-plaintext highlighter-rouge">chess.js</code>) if the move from <code class="language-plaintext highlighter-rouge">dropEvt.source</code> to <code class="language-plaintext highlighter-rouge">dropEvt.target</code> is valid. If it is, <code class="language-plaintext highlighter-rouge">game.move()</code> makes the move internally and returns information about it. If it’s <em>not</em> valid, it returns <code class="language-plaintext highlighter-rouge">null</code>.</li> <li> <code class="language-plaintext highlighter-rouge">if (move)</code>: This checks if the move was legal. <ul> <li>If <code class="language-plaintext highlighter-rouge">true</code> (legal): <ul> <li> <code class="language-plaintext highlighter-rouge">board.position(game.fen())</code>: The GIC tells the <code class="language-plaintext highlighter-rouge">board</code> object (our <a href="02_interactive_chessboard_.md">Interactive Chessboard</a>) to redraw itself to match the <em>new</em> state of the <code class="language-plaintext highlighter-rouge">game</code> (represented by <code class="language-plaintext highlighter-rouge">game.fen()</code>, a special chess notation).</li> <li> <code class="language-plaintext highlighter-rouge">updatePGN()</code> and <code class="language-plaintext highlighter-rouge">updateStatus()</code>: These (other functions in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>) update the text on the page, like the move history or game status.</li> <li> <code class="language-plaintext highlighter-rouge">createMove()</code>: This function, also part of <code class="language-plaintext highlighter-rouge">chess_actions.js</code>, is called to send the move data to our <a href="01_web_application_backend_.md">Web Application Backend</a>, which then sends it to Kafka.</li> </ul> </li> <li>If <code class="language-plaintext highlighter-rouge">false</code> (illegal): <code class="language-plaintext highlighter-rouge">return 'snapback'</code> tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> to visually return the piece to its original square.</li> </ul> </li> </ul> <p><br></p> <h3 id="3-sending-the-move-to-the-backend-createmove">3. Sending the Move to the Backend (<code class="language-plaintext highlighter-rouge">createMove</code>)</h3> <p>The <code class="language-plaintext highlighter-rouge">createMove</code> function is the part of the Game Interaction Controller that talks to our Flask backend.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified)</span>

<span class="kd">function</span> <span class="nf">createMove</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">moves</span> <span class="o">=</span> <span class="nx">game</span><span class="p">.</span><span class="nf">history</span><span class="p">({</span> <span class="na">verbose</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
  <span class="kd">const</span> <span class="nx">lastMove</span> <span class="o">=</span> <span class="nx">moves</span><span class="p">[</span><span class="nx">moves</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// Get details of the very last move</span>

  <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">v4</span><span class="p">();</span> <span class="c1">// Generate a unique ID for this move</span>
  <span class="kd">const</span> <span class="nx">player</span> <span class="o">=</span> <span class="nx">lastMove</span><span class="p">.</span><span class="nx">color</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">w</span><span class="dl">'</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Player</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">AI</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// Who made the move?</span>
  <span class="kd">const</span> <span class="nx">moveDetails</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nf">getPieceName</span><span class="p">(</span><span class="nx">lastMove</span><span class="p">.</span><span class="nx">piece</span><span class="p">)}</span><span class="s2"> from </span><span class="p">${</span><span class="nx">lastMove</span><span class="p">.</span><span class="k">from</span><span class="p">}</span><span class="s2"> to </span><span class="p">${</span><span class="nx">lastMove</span><span class="p">.</span><span class="nx">to</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span> <span class="c1">// Formatted move</span>
  
  <span class="c1">// Construct the data to send (as a string, simple for this example)</span>
  <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">sessionStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">gameId</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> 
                <span class="nx">player</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">moveDetails</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">","</span><span class="dl">'</span> <span class="o">+</span> <span class="nf">toISOStringLocal</span><span class="p">(</span><span class="k">new</span> <span class="nc">Date</span><span class="p">())</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span><span class="p">;</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="c1">// Send the move data to the backend's /add_move API endpoint using Axios</span>
  <span class="nx">axios</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://127.0.0.1:5000/add_move/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">const lastMove = ...</code>: We get the details of the move that <em>just happened</em> from the <code class="language-plaintext highlighter-rouge">game</code> object (our <a href="05_chess_game_engine_.md">Chess Game Engine</a>).</li> <li> <code class="language-plaintext highlighter-rouge">const key = uuid.v4();</code>: A unique ID is generated for each move.</li> <li> <code class="language-plaintext highlighter-rouge">const value = ...</code>: The GIC formats all the important details about the move (game ID, player, move description, timestamp) into a single string. This is the “letter” we’re going to send.</li> <li> <code class="language-plaintext highlighter-rouge">axios.post(...)</code>: This line sends an HTTP POST request to our <a href="01_web_application_backend_.md">Web Application Backend</a>. It calls the <code class="language-plaintext highlighter-rouge">/add_move</code> endpoint we saw in <a href="01_web_application_backend_.md">Chapter 1: Web Application Backend</a>, passing the <code class="language-plaintext highlighter-rouge">key</code> and <code class="language-plaintext highlighter-rouge">value</code> of the move. The backend then takes this information and publishes it to Kafka.</li> </ul> <p>There’s also an <code class="language-plaintext highlighter-rouge">onTouchSquare</code> function that handles moves made by clicking squares instead of dragging. Its logic is a bit more complex as it manages “pending moves” (where you click a piece, then click a destination square), but it follows the same core idea: ask <code class="language-plaintext highlighter-rouge">game.move()</code> for legality, then update <code class="language-plaintext highlighter-rouge">board.position()</code> and call <code class="language-plaintext highlighter-rouge">createMove()</code>.</p> <p><br></p> <h2 id="internal-workflow-3">Internal Workflow</h2> <p>Let’s visualize the full journey of a legal move with the Game Interaction Controller acting as the central hub:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant A as Interactive Chessboard (chessboard2.js)
    participant B as Game Interaction Controller (chess_actions.js)
    participant C as Chess Game Engine (chess.js)
    participant D as Web Application Backend (Flask)
    participant E as Kafka Event Bus

    User-&gt;&gt;A: Drags piece from e2 to e4
    A-&gt;&gt;B: Calls onDrop(source: 'e2', target: 'e4')
    B-&gt;&gt;C: Asks game.move({from: 'e2', to: 'e4'})
    C--&gt;&gt;B: Returns valid move object
    B-&gt;&gt;A: Tells board.position(game.fen())
    A--&gt;&gt;User: Visually updates board
    B-&gt;&gt;B: Calls createMove() (formats data)
    B-&gt;&gt;D: Sends move data via Axios POST to /add_move
    D-&gt;&gt;E: Produces 'move' event to 'moves' topic
    E--&gt;&gt;D: Confirms event received
    D--&gt;&gt;B: Sends empty response (acknowledgment)
</code></pre> <p>In this flow:</p> <ol> <li> <strong>User Interacts:</strong> You drag a piece on the visual chessboard.</li> <li> <strong>Interactive Chessboard Notifies:</strong> <code class="language-plaintext highlighter-rouge">chessboard2.js</code> detects the drag-and-drop and calls the <code class="language-plaintext highlighter-rouge">onDrop</code> function in the Game Interaction Controller.</li> <li> <strong>Game Interaction Controller Consults Engine:</strong> The <code class="language-plaintext highlighter-rouge">onDrop</code> function immediately asks the <code class="language-plaintext highlighter-rouge">game</code> object (the <a href="05_chess_game_engine_.md">Chess Game Engine</a>) if the move is legal.</li> <li> <strong>Engine Responds:</strong> The <a href="05_chess_game_engine_.md">Chess Game Engine</a> checks its rules and confirms the move is legal, returning a <code class="language-plaintext highlighter-rouge">move</code> object.</li> <li> <strong>GIC Updates Visuals:</strong> Because the move is legal, the Game Interaction Controller tells <code class="language-plaintext highlighter-rouge">chessboard2.js</code> to visually update the board with <code class="language-plaintext highlighter-rouge">board.position(game.fen())</code>.</li> <li> <strong>GIC Prepares for Backend:</strong> The GIC then calls its <code class="language-plaintext highlighter-rouge">createMove()</code> function to format the move details.</li> <li> <strong>GIC Sends to Backend:</strong> The <code class="language-plaintext highlighter-rouge">createMove()</code> function uses Axios to send this formatted move data to the <code class="language-plaintext highlighter-rouge">/add_move</code> endpoint of the <a href="01_web_application_backend_.md">Web Application Backend</a>.</li> <li> <strong>Backend Publishes to Kafka:</strong> The <a href="01_web_application_backend_.md">Web Application Backend</a> receives the data and, without processing it, immediately publishes it as a ‘move’ event to the ‘moves’ topic in the <a href="06_kafka_event_bus_.md">Kafka Event Bus</a>.</li> <li> <strong>Kafka Confirms &amp; Backend Responds:</strong> Kafka acknowledges receipt, and the backend sends an “OK” back to the Game Interaction Controller.</li> </ol> <p>This intricate dance ensures that your actions are validated by the game rules, visually reflected on the board, and then reliably sent into our data stream via Kafka.</p> <p><br></p> <h2 id="conclusion-3">Conclusion</h2> <p>You’ve now learned about the <strong>Game Interaction Controller</strong>, residing in <code class="language-plaintext highlighter-rouge">chess_actions.js</code>. This crucial component acts as the “player’s assistant,” mediating between the visual chessboard, the chess game rules, and the backend server. It interprets your moves, validates them with the <a href="05_chess_game_engine_.md">Chess Game Engine</a>, updates the visual display, and then ensures the move data is sent to the <a href="01_web_application_backend_.md">Web Application Backend</a> for Kafka publication.</p> <p>Next up, we’ll dive deeper into the “brain” of our chess game: the <a href="05_chess_game_engine_.md">Chess Game Engine</a> itself, to see how it knows all the complex rules of chess!</p> <hr> <p><br></p> <h1 id="chapter-5-chess-game-engine">Chapter 5: Chess Game Engine</h1> <p>Welcome back! In <a href="04_game_interaction_controller_.md">Chapter 4: Game Interaction Controller</a>, we saw how our <code class="language-plaintext highlighter-rouge">chess_actions.js</code> file acts as a “player’s assistant,” taking your clicks and drags from the <a href="02_interactive_chessboard_.md">Interactive Chessboard</a>. But when you try to move a piece, how does our system know if that move is actually allowed by the rules of chess? Can a knight jump over other pieces? Can a pawn move backward? What happens if your king is in danger?</p> <p>This is where the <strong>Chess Game Engine</strong> comes in! It’s the ultimate “brain” or “rulebook” of our chess game.</p> <p><br></p> <h2 id="what-is-the-chess-game-engine">What is the Chess Game Engine?</h2> <p>Think of the Chess Game Engine as the <strong>official arbiter</strong> of all chess rules. It doesn’t care about how the board looks visually, or how your actions are sent over the internet. Its single, crucial job is to <strong>understand and enforce all the rules of chess</strong>.</p> <p>Here’s what it knows:</p> <ul> <li> <strong>Piece Movements:</strong> How each type of piece (pawn, knight, bishop, rook, queen, king) is allowed to move.</li> <li> <strong>Captures:</strong> How pieces capture each other.</li> <li> <strong>Special Moves:</strong> Complex rules like castling, en passant, and pawn promotion.</li> <li> <strong>Game State:</strong> What constitutes a check, checkmate, or a draw.</li> </ul> <p>When a player (or the AI) tries to make a move, the Chess Game Engine is asked: “Is this move legal from the current board position?” It then checks all the rules and responds with a clear “Yes, that’s legal!” or “No, that’s not allowed.” If the move is legal, it updates its internal record of the board’s state.</p> <p>In our <code class="language-plaintext highlighter-rouge">kafka-chess</code> project, this powerful brain is provided by a JavaScript library called <code class="language-plaintext highlighter-rouge">chess.js</code>.</p> <p><br></p> <h3 id="use-case-checking-if-a-move-is-legal">Use Case: Checking if a Move is Legal</h3> <p>Let’s use our familiar example: You, the player, try to move a pawn from <code class="language-plaintext highlighter-rouge">e2</code> to <code class="language-plaintext highlighter-rouge">e4</code>. How does the Chess Game Engine help determine if this is a legal move?</p> <ol> <li>Your visual drag (from <a href="02_interactive_chessboard_.md">Interactive Chessboard</a>) is picked up by the <a href="04_game_interaction_controller_.md">Game Interaction Controller</a>.</li> <li>The <a href="04_game_interaction_controller_.md">Game Interaction Controller</a> then sends the proposed move (“pawn from e2 to e4”) to the <strong>Chess Game Engine</strong>.</li> <li>The Chess Game Engine looks at the current board, applies its deep knowledge of chess rules, and determines if the pawn can indeed move from <code class="language-plaintext highlighter-rouge">e2</code> to <code class="language-plaintext highlighter-rouge">e4</code>.</li> <li>It then tells the <a href="04_game_interaction_controller_.md">Game Interaction Controller</a> the verdict.</li> </ol> <p><br></p> <h2 id="how-the-chess-game-engine-works-simplified">How the Chess Game Engine Works (Simplified)</h2> <p>The <code class="language-plaintext highlighter-rouge">chess.js</code> library is initialized once when our web page loads, and then the <a href="04_game_interaction_controller_.md">Game Interaction Controller</a> constantly talks to it.</p> <p><br></p> <h3 id="1-starting-a-chess-game-instance">1. Starting a Chess Game Instance</h3> <p>In our <code class="language-plaintext highlighter-rouge">index.html</code> file, right when the page loads, we create a new <code class="language-plaintext highlighter-rouge">Chess</code> object. This is like opening the rulebook and setting up the board to its starting position.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/templates/index.html (simplified)</span>

<span class="c1">// Create new chess game instance using chess.js library</span>
<span class="kd">const</span> <span class="nx">game</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Chess</span><span class="p">();</span> <span class="c1">// This is our Chess Game Engine!</span>

<span class="c1">// ... (other code for chessboard setup)</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">const game = new Chess();</code> line creates an instance of the <code class="language-plaintext highlighter-rouge">Chess</code> object. From this point on, <code class="language-plaintext highlighter-rouge">game</code> is our direct line to the Chess Game Engine’s brain.</p> <p><br></p> <h3 id="2-asking-the-engine-to-make-a-move">2. Asking the Engine to Make a Move</h3> <p>When you drop a piece on the board, the <code class="language-plaintext highlighter-rouge">onDrop</code> function (part of our <a href="04_game_interaction_controller_.md">Game Interaction Controller</a>) is called. This function’s first job is to ask the <code class="language-plaintext highlighter-rouge">game</code> object (our Chess Game Engine) if the move is legal.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified onDrop function)</span>

<span class="kd">function</span> <span class="nf">onDrop</span> <span class="p">(</span><span class="nx">dropEvt</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. Try to make the move using the Chess Game Engine (chess.js)</span>
  <span class="kd">const</span> <span class="nx">move</span> <span class="o">=</span> <span class="nx">game</span><span class="p">.</span><span class="nf">move</span><span class="p">({</span>
    <span class="na">from</span><span class="p">:</span> <span class="nx">dropEvt</span><span class="p">.</span><span class="nx">source</span><span class="p">,</span> <span class="c1">// e.g., 'e2'</span>
    <span class="na">to</span><span class="p">:</span> <span class="nx">dropEvt</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span>   <span class="c1">// e.g., 'e4'</span>
    <span class="na">promotion</span><span class="p">:</span> <span class="dl">'</span><span class="s1">q</span><span class="dl">'</span>        <span class="c1">// (simplified) always promote to a Queen</span>
  <span class="p">})</span>

  <span class="c1">// 2. Check if the move was legal</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">move</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Move was legal! The engine updated its internal state.</span>
    <span class="c1">// Now, tell the visual board to update, send to backend, etc.</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Move was illegal!</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">snapback</span><span class="dl">'</span> <span class="c1">// Tell the visual board to return the piece</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this code snippet:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">game.move({ from: dropEvt.source, to: dropEvt.target, ... })</code> is how we ask the Chess Game Engine to <em>try</em> to make a move.</li> <li>If the move is <strong>legal</strong>, <code class="language-plaintext highlighter-rouge">game.move()</code> performs the move internally (changes the engine’s record of the board state) and returns a <code class="language-plaintext highlighter-rouge">move</code> object (containing details about the move).</li> <li>If the move is <strong>illegal</strong>, <code class="language-plaintext highlighter-rouge">game.move()</code> does <em>not</em> change the internal board state and returns <code class="language-plaintext highlighter-rouge">null</code>. This allows our <a href="04_game_interaction_controller_.md">Game Interaction Controller</a> to decide what to do next (e.g., snap the piece back).</li> </ul> <p><br></p> <h3 id="3-getting-the-boards-state">3. Getting the Board’s State</h3> <p>After a legal move is made, the Chess Game Engine’s internal representation of the board changes. To tell the <a href="02_interactive_chessboard_.md">Interactive Chessboard</a> to update its visual display, we need to get the engine’s current board state.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified after a legal move)</span>

<span class="c1">// ... inside onDrop function, after game.move() returns a valid 'move'</span>
<span class="c1">// 3. Tell chessboard2.js to update its visual position</span>
<span class="nx">board</span><span class="p">.</span><span class="nf">position</span><span class="p">(</span><span class="nx">game</span><span class="p">.</span><span class="nf">fen</span><span class="p">()).</span><span class="nf">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ... (update other elements, send to backend)</span>
<span class="p">})</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">game.fen()</code> is a powerful function provided by <code class="language-plaintext highlighter-rouge">chess.js</code>. It returns the current state of the board as a single string using a standard notation called <strong>FEN</strong> (Forsyth-Edwards Notation). This string contains all the necessary information: piece positions, whose turn it is, castling rights, en passant square, halfmove clock, and fullmove number.</li> <li>The <a href="02_interactive_chessboard_.md">Interactive Chessboard</a> (<code class="language-plaintext highlighter-rouge">board.position(...)</code>) then uses this FEN string to redraw the visual board to match the engine’s state.</li> </ul> <p><br></p> <h3 id="4-checking-game-status">4. Checking Game Status</h3> <p>The Chess Game Engine also provides functions to check the overall status of the game:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In flaskr/static/js/chess_actions.js (simplified updateStatus function)</span>

<span class="kd">function</span> <span class="nf">updateStatus</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">statusHTML</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">game</span><span class="p">.</span><span class="nf">game_over</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Is the game still ongoing?</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">game</span><span class="p">.</span><span class="nf">in_check</span><span class="p">())</span> <span class="nx">statusHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> is in check! </span><span class="dl">'</span><span class="p">;</span> <span class="c1">// Is someone in check?</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">game</span><span class="p">.</span><span class="nf">in_checkmate</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Is it checkmate?</span>
    <span class="nx">statusHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Game over: ... is in checkmate.</span><span class="dl">'</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">game</span><span class="p">.</span><span class="nf">in_stalemate</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Is it a stalemate?</span>
    <span class="nx">statusHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Game is drawn. ... is stalemated.</span><span class="dl">'</span>
  <span class="p">}</span>
  <span class="c1">// ... other draw conditions like game.in_threefold_repetition(), game.insufficient_material(), game.in_draw()</span>

  <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">gameStatus</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">statusHTML</span>
<span class="p">}</span>
</code></pre></div></div> <p>Functions like <code class="language-plaintext highlighter-rouge">game.game_over()</code>, <code class="language-plaintext highlighter-rouge">game.in_check()</code>, <code class="language-plaintext highlighter-rouge">game.in_checkmate()</code>, <code class="language-plaintext highlighter-rouge">game.in_stalemate()</code>, etc., are all part of the Chess Game Engine. They are the engine’s way of telling us the current strategic situation of the game. Our <code class="language-plaintext highlighter-rouge">updateStatus</code> function then takes this information and displays it to the player.</p> <p><br></p> <h2 id="internal-workflow-4">Internal Workflow</h2> <p>Let’s visualize how the Chess Game Engine interacts when you try to make a move:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant A as Interactive Chessboard
    participant B as Game Interaction Controller
    participant C as Chess Game Engine

    User-&gt;&gt;A: Drags piece from e2 to e4
    A-&gt;&gt;B: Calls onDrop(source: 'e2', target: 'e4')
    B-&gt;&gt;C: Calls game.move({from: 'e2', to: 'e4'}) - "Is this legal?"
    C--&gt;&gt;B: If Legal: Returns move object &amp; updates internal board state
    C--&gt;&gt;B: If Illegal: Returns null &amp; internal board state unchanged
    alt If move was Legal
        B-&gt;&gt;A: Calls board.position(game.fen()) - "Update visual!"
        A--&gt;&gt;User: Visually updates board
    else If move was Illegal
        B--&gt;&gt;A: Returns 'snapback' - "Put piece back!"
        A--&gt;&gt;User: Piece snaps back to original square
    end
</code></pre> <p>In this flow:</p> <ol> <li> <strong>User initiates move:</strong> You drag a piece on the visual board.</li> <li> <strong>Interactive Chessboard notifies:</strong> <code class="language-plaintext highlighter-rouge">chessboard2.js</code> (Interactive Chessboard) detects the drag and drop and calls the <code class="language-plaintext highlighter-rouge">onDrop</code> function in <code class="language-plaintext highlighter-rouge">chess_actions.js</code> (Game Interaction Controller).</li> <li> <strong>Game Interaction Controller asks the Engine:</strong> The <code class="language-plaintext highlighter-rouge">onDrop</code> function calls <code class="language-plaintext highlighter-rouge">game.move()</code> on the <code class="language-plaintext highlighter-rouge">Chess</code> object, providing the source and target squares. This is the moment it asks the Chess Game Engine: “Is this move allowed?”</li> <li> <strong>Chess Game Engine processes:</strong> The <code class="language-plaintext highlighter-rouge">chess.js</code> library (Chess Game Engine) performs all its complex rule checks. <ul> <li> <strong>If Legal:</strong> It updates its own internal board state to reflect the move and returns a <code class="language-plaintext highlighter-rouge">move</code> object to the <a href="04_game_interaction_controller_.md">Game Interaction Controller</a>.</li> <li> <strong>If Illegal:</strong> It leaves its internal board state unchanged and returns <code class="language-plaintext highlighter-rouge">null</code> to the <a href="04_game_interaction_controller_.md">Game Interaction Controller</a>.</li> </ul> </li> <li> <strong>Game Interaction Controller reacts:</strong> <ul> <li> <strong>If Legal:</strong> It then tells the <a href="02_interactive_chessboard_.md">Interactive Chessboard</a> to visually update using <code class="language-plaintext highlighter-rouge">board.position(game.fen())</code>, as the engine’s internal state has changed.</li> <li> <strong>If Illegal:</strong> It tells the <a href="02_interactive_chessboard_.md">Interactive Chessboard</a> to ‘snapback’ the piece, as the engine did not accept the move.</li> </ul> </li> </ol> <p><br></p> <h2 id="diving-deeper-into-chessjs-the-engines-core">Diving Deeper into <code class="language-plaintext highlighter-rouge">chess.js</code> (The Engine’s Core)</h2> <p>While we don’t write the <code class="language-plaintext highlighter-rouge">chess.js</code> library ourselves, it’s helpful to know that it contains thousands of lines of JavaScript code specifically designed to handle every possible chess scenario. It’s a highly optimized and thoroughly tested set of algorithms.</p> <p>For example, when <code class="language-plaintext highlighter-rouge">game.move()</code> is called, internally, the <code class="language-plaintext highlighter-rouge">chess.js</code> library might perform steps like:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">generate_moves()</code>: Calculates all <em>pseudo-legal</em> moves for the current player (moves that follow piece movement rules, but might leave the king in check).</li> <li> <code class="language-plaintext highlighter-rouge">attacked()</code>: Checks if a specific square is currently under attack by the opposing player’s pieces. This is crucial for determining if a king is in check.</li> <li> <code class="language-plaintext highlighter-rouge">king_attacked()</code>: A special check to see if the <em>current player’s king</em> is attacked after a move. If so, that move is illegal.</li> <li> <code class="language-plaintext highlighter-rouge">make_move()</code>: If a move is legal, this function actually updates the internal 0x88 board representation (a clever way <code class="language-plaintext highlighter-rouge">chess.js</code> stores the board) by moving the piece, handling captures, castling, en passant, etc.</li> <li> <code class="language-plaintext highlighter-rouge">undo_move()</code>: A vital function for “trying out” moves to see if they result in check, and then reverting the board state.</li> </ul> <p>You can see these functions referenced in the <code class="language-plaintext highlighter-rouge">flaskr/static/js/chess.js</code> file, though their internal logic is quite complex. The key takeaway is that <code class="language-plaintext highlighter-rouge">chess.js</code> handles all the intricate details so we don’t have to! We just use its public functions like <code class="language-plaintext highlighter-rouge">game.move()</code>, <code class="language-plaintext highlighter-rouge">game.fen()</code>, and <code class="language-plaintext highlighter-rouge">game.in_check()</code>.</p> <p><br></p> <h2 id="conclusion-4">Conclusion</h2> <p>You’ve now learned about the <strong>Chess Game Engine</strong>, powered by the <code class="language-plaintext highlighter-rouge">chess.js</code> library. It’s the “brain” of our application, understanding and enforcing all the rules of chess. It validates moves, updates the game state, and tells us whether the game is in check, checkmate, or a draw. By using <code class="language-plaintext highlighter-rouge">chess.js</code>, we can build a functional chess game without having to implement the complex rules ourselves.</p> <p>Next, we’ll explore how all the different parts of our <code class="language-plaintext highlighter-rouge">kafka-chess</code> system communicate with each other using a central “post office” called the <a href="06_kafka_event_bus_.md">Kafka Event Bus</a>!</p> <hr> <p><br></p> <h1 id="chapter-6-kafka-event-bus">Chapter 6: Kafka Event Bus</h1> <p>Welcome back! In <a href="05_chess_game_engine_.md">Chapter 5: Chess Game Engine</a>, we learned how <code class="language-plaintext highlighter-rouge">chess.js</code> acts as the “brain” of our game, understanding all the complex rules. We also saw in <a href="04_game_interaction_controller_.md">Chapter 4: Game Interaction Controller</a> how it validates your moves, and if a move is legal, it tells the <a href="01_web_application_backend_.md">Web Application Backend</a> to record it.</p> <p>But how does this “recording” work behind the scenes? And more importantly, if the backend just “records” a move, how do other parts of our system, like the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>, know about that move <em>instantly</em> without being directly connected to the game? This is a challenge!</p> <p>Imagine you’re trying to send a letter to many different friends, but you don’t want to write a separate letter for each one. You want a single place where you can drop off your letter, and then anyone who cares about what you wrote can pick it up. This is exactly the problem that the <strong>Kafka Event Bus</strong> solves!</p> <p><br></p> <h2 id="what-is-the-kafka-event-bus">What is the Kafka Event Bus?</h2> <p>The <strong>Kafka Event Bus</strong> is like a super-efficient <strong>central data highway</strong> or a <strong>high-tech post office</strong> for all the real-time events happening in our <code class="language-plaintext highlighter-rouge">kafka-chess</code> system. When something important happens – like a player making a move, or a game starting or ending – this information is immediately sent to Kafka.</p> <p>Its main jobs are:</p> <ol> <li> <strong>Collecting Events (Producing):</strong> It receives messages from various parts of our application (like the <a href="01_web_application_backend_.md">Web Application Backend</a> when a move is made). Think of this as putting a letter into a specific mailbox.</li> <li> <strong>Organizing Events (Topics):</strong> It neatly stores these messages in different “topics.” A topic is like a specific mail slot or department in the post office. All chess moves go into a <code class="language-plaintext highlighter-rouge">moves</code> topic, and game start/end events go into a <code class="language-plaintext highlighter-rouge">games</code> topic.</li> <li> <strong>Broadcasting Events (Consuming):</strong> It allows different parts of the application (like the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> or the <a href="08_live_data_update_workers_.md">Live Data Update Workers</a>) to “subscribe” to these topics and automatically receive the messages as they happen. This means senders don’t need to know who the receivers are!</li> </ol> <p>This “bus” or “post office” setup makes our system very flexible. Each part can focus on its own job without worrying about how to directly talk to every other part.</p> <p><br></p> <h3 id="use-case-broadcasting-a-chess-move">Use Case: Broadcasting a Chess Move</h3> <p>Let’s use our familiar example: You, the player, move a pawn from <code class="language-plaintext highlighter-rouge">e2</code> to <code class="language-plaintext highlighter-rouge">e4</code>.</p> <ol> <li>The <a href="04_game_interaction_controller_.md">Game Interaction Controller</a> validates the move and tells the <a href="01_web_application_backend_.md">Web Application Backend</a> about it.</li> <li>The <strong>Web Application Backend</strong> then immediately sends this move information as a “message” (also called an “event”) to the Kafka Event Bus. It sends it to the <code class="language-plaintext highlighter-rouge">moves</code> topic.</li> <li>Now, the <strong>Kafka Event Bus</strong> holds onto this message.</li> <li>The <strong><a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a></strong> (which is always “listening” to the <code class="language-plaintext highlighter-rouge">moves</code> topic) receives this message and processes it for statistics.</li> <li>The <strong><a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a></strong> (which gets its data from Flink) then updates its “Recent Moves” section to show your move!</li> </ol> <p>Notice that the <a href="01_web_application_backend_.md">Web Application Backend</a> never directly talks to Flink or Streamlit. It just drops the message into Kafka, and Kafka handles the rest.</p> <p><br></p> <h2 id="how-the-kafka-event-bus-works-simplified">How the Kafka Event Bus Works (Simplified)</h2> <p>Kafka isn’t a part of our Python or JavaScript code directly. Instead, it’s a powerful separate program that runs in the background. We tell Docker (a tool that helps run programs in isolated “containers”) to start Kafka for us.</p> <p><br></p> <h3 id="1-setting-up-the-kafka-post-office-configuration">1. Setting Up the Kafka “Post Office” (Configuration)</h3> <p>We define Kafka as a service in our <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file. This file tells Docker how to build and run all the different parts of our system, including Kafka.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In kafka/docker-compose.yml (simplified)</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">broker</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">apache/kafka:latest</span> <span class="c1"># Use the official Kafka image</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">broker</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">broker</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">9092:9092'</span> <span class="c1"># This makes Kafka available on your computer at port 9092</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="c1"># ... other Kafka settings (like where it stores data, how it communicates)</span>
      <span class="na">KAFKA_ADVERTISED_LISTENERS</span><span class="pi">:</span> <span class="s1">'</span><span class="s">PLAINTEXT_HOST://localhost:9092,PLAINTEXT://broker:19092'</span>
</code></pre></div></div> <p>In this snippet:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">image: apache/kafka:latest</code> tells Docker to download and use the latest version of Kafka.</li> <li> <code class="language-plaintext highlighter-rouge">ports: - '9092:9092'</code> is very important! It means that whatever traffic goes to port <code class="language-plaintext highlighter-rouge">9092</code> on <em>your computer</em> will be sent to port <code class="language-plaintext highlighter-rouge">9092</code> <em>inside the Kafka container</em>. This is how our other applications (like Flask) can connect to Kafka using <code class="language-plaintext highlighter-rouge">localhost:9092</code>.</li> <li> <code class="language-plaintext highlighter-rouge">KAFKA_ADVERTISED_LISTENERS</code> is like Kafka announcing its address so other applications know where to send messages. Here, <code class="language-plaintext highlighter-rouge">localhost:9092</code> is the address other applications outside the Docker network will use.</li> </ul> <p>This <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file effectively sets up the entire “post office building” for our event bus.</p> <p><br></p> <h3 id="2-sending-messages-to-kafka-producing">2. Sending Messages to Kafka (Producing)</h3> <p>As we saw briefly in <a href="01_web_application_backend_.md">Chapter 1: Web Application Backend</a>, our Flask backend is responsible for “producing” (sending) messages to Kafka.</p> <p>First, the Flask application needs to connect to Kafka by creating a <code class="language-plaintext highlighter-rouge">Producer</code> object.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In flaskr/__init__.py (simplified)
</span>
<span class="kn">from</span> <span class="n">confluent_kafka</span> <span class="kn">import</span> <span class="n">Producer</span>

<span class="n">KAFKA_SERVER</span> <span class="o">=</span> <span class="sh">"</span><span class="s">localhost:9092</span><span class="sh">"</span> <span class="c1"># The address of our Kafka "post office"
</span>
<span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">bootstrap.servers</span><span class="sh">"</span><span class="p">:</span> <span class="n">KAFKA_SERVER</span><span class="p">,</span> <span class="c1"># Tell the producer where Kafka is
</span>    <span class="sh">"</span><span class="s">acks</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">all</span><span class="sh">"</span><span class="p">,</span> <span class="c1"># Make sure messages are safely delivered
</span><span class="p">}</span>

<span class="c1"># Create the Producer instance, our "post office worker"
</span><span class="n">producer</span> <span class="o">=</span> <span class="nc">Producer</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Producer(config)</code> creates a special object that knows how to send messages to Kafka.</li> <li> <code class="language-plaintext highlighter-rouge">bootstrap.servers</code> is the key setting that tells the producer <em>where</em> to find Kafka (using the <code class="language-plaintext highlighter-rouge">localhost:9092</code> address we exposed in <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>).</li> </ul> <p>Once the producer is set up, the Flask backend can send a message whenever a move or game event happens.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In flaskr/__init__.py (simplified add_move route)
</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/add_move/&lt;key&gt;/&lt;value&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">POST</span><span class="sh">"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">add_move</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">topic</span> <span class="o">=</span> <span class="sh">"</span><span class="s">moves</span><span class="sh">"</span> <span class="c1"># Our "mailbox" for chess moves
</span>
    <span class="c1"># Use our Kafka producer to send the message
</span>    <span class="c1"># value is the actual move data, key is a unique ID
</span>    <span class="n">producer</span><span class="p">.</span><span class="nf">produce</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> 

    <span class="c1"># Make sure the message is sent before continuing
</span>    <span class="n">producer</span><span class="p">.</span><span class="nf">poll</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
    <span class="n">producer</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>

    <span class="k">return</span> <span class="sh">""</span> <span class="c1"># Send an empty response back to the frontend
</span></code></pre></div></div> <p>In this code:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">topic = "moves"</code>: This specifies which “mailbox” or “department” in Kafka this message belongs to.</li> <li> <code class="language-plaintext highlighter-rouge">producer.produce(topic, value, key)</code>: This is the critical line! It tells our <code class="language-plaintext highlighter-rouge">producer</code> to put the <code class="language-plaintext highlighter-rouge">value</code> (the move details) into the <code class="language-plaintext highlighter-rouge">moves</code> <code class="language-plaintext highlighter-rouge">topic</code>, using <code class="language-plaintext highlighter-rouge">key</code> as a unique identifier for that message.</li> <li> <code class="language-plaintext highlighter-rouge">producer.poll()</code> and <code class="language-plaintext highlighter-rouge">producer.flush()</code>: These lines ensure the message is actually sent out and confirmed by Kafka before the backend finishes its job.</li> </ul> <p>The <code class="language-plaintext highlighter-rouge">add_game</code> route works in a very similar way, but it sends game start/end events to the <code class="language-plaintext highlighter-rouge">games</code> topic instead.</p> <p><br></p> <h3 id="3-receiving-messages-from-kafka-consuming">3. Receiving Messages from Kafka (Consuming)</h3> <p>Other parts of our application, like the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a>, are designed to “consume” (read) messages from Kafka topics. They act like subscribers who get new mail as soon as it arrives in their specific mailbox.</p> <p>In our system, the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> uses powerful SQL-like commands to connect to Kafka and start reading the data stream.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_table_env.py (simplified)
</span>
<span class="k">class</span> <span class="nc">TableEnvCustomized</span><span class="p">:</span>
    <span class="c1"># ... (initialization of Flink table environment)
</span>
    <span class="k">def</span> <span class="nf">create_source_tables</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Create Kafka source tables for games and moves data.</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">execute_sql</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"""</span><span class="s">
        CREATE TABLE games (
            game_id VARCHAR
            ,start_time TIMESTAMP(3)
            ,end_time TIMESTAMP(3)
        ) WITH (
            </span><span class="sh">'</span><span class="s">connector</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">kafka</span><span class="sh">'</span><span class="s">, # Tell Flink to connect to Kafka
            </span><span class="sh">'</span><span class="s">topic</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">games</span><span class="sh">'</span><span class="s">,     # Which Kafka topic to read from
            </span><span class="sh">'</span><span class="s">properties.bootstrap.servers</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">localhost:9092</span><span class="sh">'</span><span class="s">, # Kafka</span><span class="sh">'</span><span class="s">s address
            </span><span class="sh">'</span><span class="s">scan.startup.mode</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">timestamp</span><span class="sh">'</span><span class="s">, # Start reading from a specific time
            </span><span class="sh">'</span><span class="s">value.format</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">csv</span><span class="sh">'</span><span class="s"> # How the messages are formatted
        )
    </span><span class="sh">"""</span>
        <span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">execute_sql</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"""</span><span class="s">
        CREATE TABLE moves (
            move_id VARCHAR
            ,game_id VARCHAR
            ,player VARCHAR
            ,move VARCHAR
            ,move_time TIMESTAMP(0)
        ) WITH (
            </span><span class="sh">'</span><span class="s">connector</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">kafka</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">topic</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">moves</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">properties.bootstrap.servers</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">localhost:9092</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">scan.startup.mode</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">timestamp</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">value.format</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">csv</span><span class="sh">'</span><span class="s">
        )
    </span><span class="sh">"""</span>
        <span class="p">)</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">CREATE TABLE games (...) WITH (...)</code>: This is a special SQL command telling Flink to set up a “virtual table” that is actually linked to a Kafka topic.</li> <li> <code class="language-plaintext highlighter-rouge">'connector' = 'kafka'</code>: This explicitly tells Flink, “I want to connect to Kafka!”</li> <li> <code class="language-plaintext highlighter-rouge">'topic' = 'games'</code> (or <code class="language-plaintext highlighter-rouge">'moves'</code>): This tells Flink <em>which specific Kafka topic</em> to listen to. Flink will only receive messages from this topic.</li> <li> <code class="language-plaintext highlighter-rouge">'properties.bootstrap.servers' = 'localhost:9092'</code>: Again, this is the address where Flink knows to find our Kafka “post office.”</li> <li> <code class="language-plaintext highlighter-rouge">'value.format' = 'csv'</code>: This tells Flink how to understand the data inside the messages (we’re sending them as simple comma-separated values).</li> </ul> <p>Once these “source tables” are created, Flink can then start reading the incoming messages as a continuous stream of data, ready to perform analytics on them.</p> <p><br></p> <h2 id="internal-workflow-5">Internal Workflow</h2> <p>Let’s visualize how a chess move travels through our system, with Kafka as the central hub:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant B as Web Application Backend (Flask)
    participant K as Kafka Event Bus
    participant F as Flink Analytics Engine
    participant S as Streamlit Analytics Dashboard

    B-&gt;&gt;K: Publishes 'move' event to 'moves' topic (Producer)
    K--&gt;&gt;B: Acknowledges receipt
    K-&gt;&gt;F: Streams 'move' events from 'moves' topic (Consumer)
    F-&gt;&gt;F: Processes and aggregates move data
    F-&gt;&gt;S: Provides processed data to Streamlit workers
    S--&gt;&gt;User: Displays updated "Recent Moves"
</code></pre> <p>In this flow:</p> <ol> <li> <strong>Backend Publishes:</strong> When you make a move, the <a href="01_web_application_backend_.md">Web Application Backend</a> sends that move as a message (an “event”) to the <a href="06_kafka_event_bus_.md">Kafka Event Bus</a>, specifically to the <code class="language-plaintext highlighter-rouge">moves</code> topic.</li> <li> <strong>Kafka Acknowledges:</strong> Kafka confirms it has received and stored the message safely.</li> <li> <strong>Flink Consumes:</strong> The <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> is constantly “listening” to the <code class="language-plaintext highlighter-rouge">moves</code> topic in Kafka. As soon as a new message arrives, Flink automatically picks it up.</li> <li> <strong>Flink Processes:</strong> Flink then uses its powerful capabilities to process this raw move data (e.g., counting moves, calculating statistics).</li> <li> <strong>Flink Feeds Streamlit:</strong> Flink makes its processed data available to the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a> through its workers.</li> <li> <strong>Streamlit Displays:</strong> The <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a> updates its display with the latest information, including your recent move.</li> </ol> <p>This is the beauty of the event bus: each part of the system is loosely connected. The backend doesn’t need to know about Flink or Streamlit; it just knows how to drop messages onto the Kafka highway. And Flink and Streamlit don’t need to know about the backend; they just know how to pick up messages from Kafka. This makes the system robust and easy to expand.</p> <p><br></p> <h2 id="conclusion-5">Conclusion</h2> <p>You’ve now learned about the <strong>Kafka Event Bus</strong>, which acts as the central “data highway” for all real-time events in our <code class="language-plaintext highlighter-rouge">kafka-chess</code> system. We saw how it’s configured using <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, how the <a href="01_web_application_backend_.md">Web Application Backend</a> sends messages (produces them) to specific Kafka topics, and how other parts like the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> read messages (consume them) from these topics. This event-driven architecture makes our system scalable, flexible, and real-time.</p> <p>Next, we’ll dive into the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> to see how it takes the raw data from Kafka and turns it into useful insights for our analytics dashboard!</p> <hr> <p><br></p> <h1 id="chapter-7-flink-analytics-engine">Chapter 7: Flink Analytics Engine</h1> <p>Welcome back! In <a href="06_kafka_event_bus_.md">Chapter 6: Kafka Event Bus</a>, we learned how our chess system uses Kafka as a central “data highway” to send real-time information about chess moves and game starts/ends. So now, all this raw event data is flowing into Kafka topics like <code class="language-plaintext highlighter-rouge">moves</code> and <code class="language-plaintext highlighter-rouge">games</code>.</p> <p>But what’s the point of having all this data if we can’t understand it? How do we take that raw stream of “player A moved pawn from e2 to e4” and turn it into useful insights like: “There are currently 5 active games,” or “Here are the last 10 moves made across all games”? We need a powerful tool to continuously <strong>analyze</strong> this live stream of data.</p> <p>This is where the <strong>Flink Analytics Engine</strong> comes in!</p> <p><br></p> <h2 id="what-is-the-flink-analytics-engine">What is the Flink Analytics Engine?</h2> <p>Imagine you have a super-smart <strong>data scientist</strong> who works tirelessly, day and night, watching every single piece of information that flows through Kafka. This data scientist’s job isn’t to play chess, but to constantly look for patterns, count things, and summarize what’s happening <em>right now</em> in all the games.</p> <p>The <strong>Flink Analytics Engine</strong> is our project’s version of that tireless data scientist. It uses <strong>Apache Flink</strong>, a powerful tool designed for real-time data processing.</p> <p>Its main jobs are:</p> <ol> <li> <strong>Listening to Kafka (Data Ingestion):</strong> It continuously connects to our <a href="06_kafka_event_bus_.md">Kafka Event Bus</a> and reads every new chess move and game event as soon as it appears.</li> <li> <strong>Processing Data (Analysis):</strong> It then takes this raw stream of events and applies special “recipes” (called queries) to count, filter, and aggregate the data. For example, it can count how many games are currently in progress or list the most recent moves.</li> <li> <strong>Providing Insights (Results):</strong> It makes these live statistics and processed data available for other parts of our system, particularly the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>.</li> </ol> <p>In our project, the <code class="language-plaintext highlighter-rouge">TableEnvCustomized</code> class (found in <code class="language-plaintext highlighter-rouge">streamlit/utils/utils_table_env.py</code>) represents this “data scientist.” It’s the part of our code that sets up and uses Apache Flink.</p> <p><br></p> <h3 id="use-case-calculating-live-chess-statistics">Use Case: Calculating Live Chess Statistics</h3> <p>Let’s say you’re looking at the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a> and you see numbers like “Active Games: 3” or a list of “Recent Moves.” How does the system know these numbers and lists in real-time?</p> <p>The Flink Analytics Engine is constantly doing the work:</p> <ol> <li>It’s always connected to Kafka, receiving every new move and game event.</li> <li>It runs continuous calculations in the background: <ul> <li>“How many unique game IDs have started but not yet ended?” (for active games)</li> <li>“What are the last N entries in the <code class="language-plaintext highlighter-rouge">moves</code> stream?” (for recent moves)</li> </ul> </li> <li>It then provides these updated results to the dashboard, ensuring you always see the latest information.</li> </ol> <p><br></p> <h2 id="how-the-flink-analytics-engine-works-simplified">How the Flink Analytics Engine Works (Simplified)</h2> <p>The core of our Flink Analytics Engine is the <code class="language-plaintext highlighter-rouge">TableEnvCustomized</code> class, which uses PyFlink (the Python API for Apache Flink) to interact with our data streams.</p> <p><br></p> <h3 id="1-setting-up-the-data-scientists-workbench">1. Setting Up the “Data Scientist’s Workbench”</h3> <p>Before Flink can start analyzing, it needs to be configured. This involves setting up a <code class="language-plaintext highlighter-rouge">TableEnvironment</code> (Flink’s main workplace) and telling it where to find special connector files (JARs) that allow it to talk to Kafka.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_table_env.py (simplified __init__)
</span><span class="kn">from</span> <span class="n">pyflink.table</span> <span class="kn">import</span> <span class="n">EnvironmentSettings</span><span class="p">,</span> <span class="n">TableEnvironment</span>
<span class="kn">import</span> <span class="n">os</span> <span class="c1"># For accessing environment variables
</span>
<span class="k">class</span> <span class="nc">TableEnvCustomized</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># Create a streaming table environment - this is Flink's main workspace
</span>        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span> <span class="o">=</span> <span class="n">TableEnvironment</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
            <span class="n">EnvironmentSettings</span><span class="p">.</span><span class="nf">in_streaming_mode</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># Tell Flink where to find the Kafka connector
</span>        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">get_config</span><span class="p">().</span><span class="nf">set</span><span class="p">(</span>
            <span class="sh">"</span><span class="s">pipeline.jars</span><span class="sh">"</span><span class="p">,</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">file:////</span><span class="si">{</span><span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">'</span><span class="s">ABSOLUTE_PATH_TO_JAR_FILE</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></div> <p>In this code:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">TableEnvironment.create(EnvironmentSettings.in_streaming_mode())</code> creates the special Flink environment designed for continuous, real-time data processing (streaming).</li> <li> <code class="language-plaintext highlighter-rouge">self.table_env.get_config().set("pipeline.jars", ...)</code> is a crucial line. It tells Flink, “To connect to Kafka, you’ll need this special tool (JAR file).” This JAR file is downloaded separately and its path is set as an environment variable in our setup.</li> </ul> <p><br></p> <h3 id="2-teaching-flink-about-kafka-data-source-tables">2. Teaching Flink About Kafka Data (“Source Tables”)</h3> <p>Next, our Flink “data scientist” needs to understand the structure of the data coming from Kafka. We do this by defining “virtual tables” that are actually connected to our Kafka topics. Think of this as giving Flink a “schema” or a “blueprint” for the data it’s about to receive.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_table_env.py (simplified create_source_tables)
</span>
    <span class="k">def</span> <span class="nf">create_source_tables</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Create Kafka source tables for games and moves data.</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">execute_sql</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"""</span><span class="s">
        CREATE TABLE games (
            game_id VARCHAR
            ,start_time TIMESTAMP(3)
            ,end_time TIMESTAMP(3)
        ) WITH (
            </span><span class="sh">'</span><span class="s">connector</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">kafka</span><span class="sh">'</span><span class="s">, # Tell Flink: use the Kafka connector
            </span><span class="sh">'</span><span class="s">topic</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">games</span><span class="sh">'</span><span class="s">,     # Listen to the </span><span class="sh">'</span><span class="s">games</span><span class="sh">'</span><span class="s"> Kafka topic
            </span><span class="sh">'</span><span class="s">properties.bootstrap.servers</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">localhost:9092</span><span class="sh">'</span><span class="s">, # Kafka</span><span class="sh">'</span><span class="s">s address
            </span><span class="sh">'</span><span class="s">scan.startup.mode</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">timestamp</span><span class="sh">'</span><span class="s">, # Start reading from a specific time
            </span><span class="sh">'</span><span class="s">value.format</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">csv</span><span class="sh">'</span><span class="s"> # Data format (simple comma-separated)
        )
    </span><span class="sh">"""</span>
        <span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">execute_sql</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"""</span><span class="s">
        CREATE TABLE moves (
            move_id VARCHAR
            ,game_id VARCHAR
            ,player VARCHAR
            ,move VARCHAR
            ,move_time TIMESTAMP(0)
        ) WITH (
            </span><span class="sh">'</span><span class="s">connector</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">kafka</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">topic</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">moves</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">properties.bootstrap.servers</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">localhost:9092</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">scan.startup.mode</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">timestamp</span><span class="sh">'</span><span class="s">,
            </span><span class="sh">'</span><span class="s">value.format</span><span class="sh">'</span><span class="s"> = </span><span class="sh">'</span><span class="s">csv</span><span class="sh">'</span><span class="s">
        )
    </span><span class="sh">"""</span>
        <span class="p">)</span>
</code></pre></div></div> <p>In this code:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">CREATE TABLE ... WITH (...)</code> is a SQL-like command that registers a new “table” within Flink. But this isn’t a normal table; it’s a <strong>streaming table</strong> that represents our Kafka data.</li> <li> <code class="language-plaintext highlighter-rouge">'connector' = 'kafka'</code> explicitly tells Flink to use the Kafka connector we linked earlier.</li> <li> <code class="language-plaintext highlighter-rouge">'topic' = 'games'</code> (or <code class="language-plaintext highlighter-rouge">'moves'</code>) specifies which Kafka topic Flink should continuously read messages from.</li> <li> <code class="language-plaintext highlighter-rouge">'properties.bootstrap.servers' = 'localhost:9092'</code> is the address of our <a href="06_kafka_event_bus_.md">Kafka Event Bus</a>.</li> <li> <code class="language-plaintext highlighter-rouge">'value.format' = 'csv'</code> indicates that the data arriving in Kafka is in a simple comma-separated format.</li> </ul> <p>After these commands run, Flink is now actively listening to both the <code class="language-plaintext highlighter-rouge">games</code> and <code class="language-plaintext highlighter-rouge">moves</code> Kafka topics, ready to process the data as it arrives.</p> <p><br></p> <h3 id="3-asking-flink-for-real-time-insights-queries">3. Asking Flink for Real-Time Insights (Queries)</h3> <p>Once Flink is connected and understands the data, we can ask it questions (queries) about the live streams. The <code class="language-plaintext highlighter-rouge">TableEnvCustomized</code> class has methods to get specific insights.</p> <p>Here’s how we get the count of active and completed games:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_table_env.py (simplified get_games_stats)
</span>
    <span class="k">def</span> <span class="nf">get_games_stats</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Get count of active and completed games.</span><span class="sh">"""</span>
        <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">execute_sql</span><span class="p">(</span>
            <span class="sh">"""</span><span class="s">
      SELECT 
        SUM(CASE WHEN record_count = 1 THEN 1 ELSE 0 END) active_game_count
        ,SUM(CASE WHEN record_count = 2 THEN 1 ELSE 0 END) completed_game_count
      FROM (
        SELECT game_id, COUNT(*) record_count FROM games 
        GROUP BY game_id
      )
      </span><span class="sh">"""</span>
        <span class="p">).</span><span class="nf">collect</span><span class="p">()</span> <span class="k">as</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="nf">yield </span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1"># Continuously yield new results
</span></code></pre></div></div> <p>Explanation:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">self.table_env.execute_sql(...)</code> tells Flink to run a SQL query.</li> <li>The inner <code class="language-plaintext highlighter-rouge">SELECT game_id, COUNT(*) record_count FROM games GROUP BY game_id</code> counts how many events (<code class="language-plaintext highlighter-rouge">start_time</code> and <code class="language-plaintext highlighter-rouge">end_time</code>) exist for each <code class="language-plaintext highlighter-rouge">game_id</code>. A game that only has a <code class="language-plaintext highlighter-rouge">start_time</code> will have <code class="language-plaintext highlighter-rouge">record_count = 1</code> (an active game). A game that also has an <code class="language-plaintext highlighter-rouge">end_time</code> will have <code class="language-plaintext highlighter-rouge">record_count = 2</code> (a completed game).</li> <li>The outer <code class="language-plaintext highlighter-rouge">SELECT SUM(CASE WHEN record_count = 1 THEN 1 ELSE 0 END) ...</code> then sums these up to give us the total active and completed game counts.</li> <li> <code class="language-plaintext highlighter-rouge">.collect()</code> starts a continuous stream of results. As soon as a new game starts or ends (and new data arrives in Kafka), Flink re-calculates, and a new <code class="language-plaintext highlighter-rouge">result</code> is sent.</li> <li> <code class="language-plaintext highlighter-rouge">yield (result)</code> means this function doesn’t return just one answer; it keeps providing new answers as they become available.</li> </ul> <p>Similarly, to get the list of recent moves, we simply select from the <code class="language-plaintext highlighter-rouge">moves</code> table:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_table_env.py (simplified get_moves)
</span>
    <span class="k">def</span> <span class="nf">get_moves</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Get all chess moves data formatted for display.</span><span class="sh">"""</span>
        <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">execute_sql</span><span class="p">(</span>
            <span class="sh">"</span><span class="s">SELECT game_id, player, move, move_time FROM moves</span><span class="sh">"</span>
        <span class="p">).</span><span class="nf">collect</span><span class="p">()</span> <span class="k">as</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">moves</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="c1"># Filter out initial dummy records
</span>                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">"</span><span class="s">dummy</span><span class="sh">"</span><span class="p">:</span> 
                    <span class="n">moves</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="c1"># Convert to a Pandas DataFrame for Streamlit display
</span>                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span>
                    <span class="n">moves</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">Game ID</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Player</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Move</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Move Timestamp</span><span class="sh">"</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="nf">yield </span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="c1"># Continuously yield new DataFrames
</span></code></pre></div></div> <p>This <code class="language-plaintext highlighter-rouge">get_moves()</code> function simply asks Flink to give it all the data from the <code class="language-plaintext highlighter-rouge">moves</code> Kafka stream. As new moves arrive, Flink adds them to the stream, and our function receives them, bundles them into a Pandas DataFrame, and <code class="language-plaintext highlighter-rouge">yield</code>s them. The <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a> (<a href="08_live_data_update_workers_.md">Live Data Update Workers</a> specifically) then receives these DataFrames and updates the display.</p> <p><br></p> <h2 id="internal-workflow-6">Internal Workflow</h2> <p>Let’s visualize how the Flink Analytics Engine acts as the central processor, taking data from Kafka and preparing it for the dashboard:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant K as Kafka Event Bus
    participant F as Flink Analytics Engine (TableEnvCustomized)
    participant W as Live Data Update Workers
    participant S as Streamlit Analytics Dashboard

    K-&gt;&gt;F: Streams new 'move' &amp; 'game' events continuously
    loop Real-time Analysis
        F-&gt;&gt;F: Flink executes continuous SQL queries (e.g., SUM, COUNT, SELECT)
        F-&gt;&gt;F: Aggregates and processes data
        W-&gt;&gt;F: Worker calls Flink's get_games_stats() or get_moves()
        F--&gt;&gt;W: Flink yields updated results (e.g., (3, 2) or DataFrame of moves)
        W-&gt;&gt;S: Worker updates Streamlit UI with new data
    end
</code></pre> <p>In this flow:</p> <ol> <li> <strong>Kafka Streams Events to Flink:</strong> The <a href="06_kafka_event_bus_.md">Kafka Event Bus</a> continuously sends new game and move events to the Flink Analytics Engine. Flink is always listening.</li> <li> <strong>Flink Processes Continuously:</strong> Flink uses the “source tables” and “queries” we defined to constantly re-calculate statistics and update the list of recent moves as new data arrives. This happens automatically and in real-time.</li> <li> <strong>Workers Request Data:</strong> The <a href="08_live_data_update_workers_.md">Live Data Update Workers</a> (running as part of our <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>) periodically call <code class="language-plaintext highlighter-rouge">TableEnvCustomized</code>’s <code class="language-plaintext highlighter-rouge">get_games_stats()</code> and <code class="language-plaintext highlighter-rouge">get_moves()</code> methods.</li> <li> <strong>Flink Yields Results:</strong> Because these Flink queries are continuous streams, Flink <code class="language-plaintext highlighter-rouge">yield</code>s (provides) the latest calculated results to the workers.</li> <li> <strong>Workers Update Dashboard:</strong> The workers then take these fresh results and use Streamlit commands to update the metrics and tables on the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>.</li> </ol> <p>This continuous cycle is what makes our dashboard “live” and constantly updated with the latest chess activity.</p> <p><br></p> <h2 id="conclusion-6">Conclusion</h2> <p>You’ve now learned about the <strong>Flink Analytics Engine</strong>, which is the “data scientist” of our <code class="language-plaintext highlighter-rouge">kafka-chess</code> project. It uses Apache Flink to continuously read raw game and move data from the <a href="06_kafka_event_bus_.md">Kafka Event Bus</a>, apply powerful SQL-like queries to analyze it in real-time, and make the processed insights available for our dashboard. This allows us to see live statistics like active games and recent moves, transforming raw events into meaningful information.</p> <p>Next up, we’ll dive into the <a href="08_live_data_update_workers_.md">Live Data Update Workers</a>, which are the actual “reporters” that fetch this processed data from Flink and display it on the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>!</p> <hr> <p><br></p> <h1 id="chapter-8-live-data-update-workers">Chapter 8: Live Data Update Workers</h1> <p>Welcome back! In <a href="07_flink_analytics_engine_.md">Chapter 7: Flink Analytics Engine</a>, we learned how Apache Flink acts as our “data scientist,” tirelessly analyzing the raw game and move data flowing through the <a href="06_kafka_event_bus_.md">Kafka Event Bus</a> and preparing useful insights. But once Flink has calculated “3 active games” or “the last 5 moves,” how does that information <em>actually get onto your screen</em> in the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a> and keep updating automatically?</p> <p>Imagine you’re watching a news channel that needs to show live scores or breaking news. You don’t want to press a “refresh” button every few seconds, right? You want the numbers and headlines to update by themselves, instantly. This is exactly the job of the <strong>Live Data Update Workers</strong>!</p> <p><br></p> <h2 id="what-are-the-live-data-update-workers">What are the Live Data Update Workers?</h2> <p>The <strong>Live Data Update Workers</strong> are like our dashboard’s very own <strong>“auto-refresh crew”</strong> or <strong>“dedicated news reporters.”</strong> They are special Python programs that run quietly in the background, making sure the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a> always shows the most current information.</p> <p>Their main jobs are:</p> <ol> <li> <strong>Continuous Fetching:</strong> They regularly ask the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> for the very latest processed data (like updated game counts or new moves).</li> <li> <strong>Targeted Updating:</strong> Each worker is responsible for updating a <em>specific</em> part of the Streamlit dashboard. One worker might update the “Game Statistics” numbers, another updates the “Recent Moves” list, and so on.</li> <li> <strong>Real-Time Display:</strong> By continuously fetching and updating, they ensure that the dashboard remains live and dynamic, without you ever needing to click a refresh button.</li> </ol> <p>These workers are implemented as <code class="language-plaintext highlighter-rouge">WorkerThread</code> classes in the <code class="language-plaintext highlighter-rouge">streamlit/utils/utils_worker.py</code> file. They use Python’s <code class="language-plaintext highlighter-rouge">threading</code> feature to run multiple tasks at the same time, keeping your dashboard responsive.</p> <p><br></p> <h3 id="use-case-keeping-the-dashboard-live">Use Case: Keeping the Dashboard Live</h3> <p>Let’s say you’re watching the <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>. You see the “Active Games” count, “Games Completed Today,” and a “Recent Moves” table. How do these constantly update?</p> <ol> <li>One <strong>Live Data Update Worker</strong> (let’s call it Worker A) is constantly asking the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> for the latest game statistics.</li> <li>As soon as Flink has new stats (e.g., a game starts or ends), Worker A receives them.</li> <li>Worker A immediately tells Streamlit to update the “Active Games” and “Games Completed Today” numbers on the dashboard.</li> <li>At the same time, another <strong>Live Data Update Worker</strong> (Worker B) is doing the same for recent moves, fetching them from Flink and updating the “Recent Moves” table on the dashboard.</li> </ol> <p>This happens continuously, giving you a smooth, real-time view of all the chess activity.</p> <p><br></p> <h2 id="how-the-live-data-update-workers-work-simplified">How the Live Data Update Workers Work (Simplified)</h2> <p>The core <code class="language-plaintext highlighter-rouge">streamlit/app.py</code> script starts these workers when the dashboard loads. The workers then run independently in the background.</p> <p><br></p> <h3 id="1-starting-the-auto-refresh-crew">1. Starting the “Auto-Refresh Crew”</h3> <p>In <code class="language-plaintext highlighter-rouge">streamlit/app.py</code>, after setting up the page layout and connecting to Flink, we call a special function <code class="language-plaintext highlighter-rouge">run_workers</code> to kick off all the data update threads.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/app.py (simplified)
</span><span class="kn">import</span> <span class="n">streamlit</span> <span class="k">as</span> <span class="n">st</span>
<span class="kn">from</span> <span class="n">utils.utils_table_env</span> <span class="kn">import</span> <span class="n">TableEnvCustomized</span>
<span class="kn">from</span> <span class="n">utils.utils_worker</span> <span class="kn">import</span> <span class="n">run_workers</span> <span class="c1"># Import our worker startup function
</span>
<span class="c1"># ... (page layout code)
</span>
<span class="c1"># Initialize PyFlink table environment (our Flink "data scientist")
</span><span class="n">table_env</span> <span class="o">=</span> <span class="nc">TableEnvCustomized</span><span class="p">()</span>
<span class="n">table_env</span><span class="p">.</span><span class="nf">create_source_tables</span><span class="p">()</span> <span class="c1"># Set up connections to data sources
</span>
<span class="c1"># Start the data processing workers
</span><span class="k">try</span><span class="p">:</span>
    <span class="nf">run_workers</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col3</span><span class="p">,</span> <span class="n">col4</span><span class="p">,</span> <span class="n">table_env</span><span class="p">)</span> <span class="c1"># Pass columns and Flink connection
</span><span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
    <span class="n">st</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">Unable to fetch live data.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">run_workers(...)</code> is the key function that creates and starts our “reporter” threads.</li> <li>It passes the <code class="language-plaintext highlighter-rouge">col1</code>, <code class="language-plaintext highlighter-rouge">col2</code>, <code class="language-plaintext highlighter-rouge">col4</code> (which are specific sections of our Streamlit dashboard page) to the workers, so each worker knows <em>where</em> on the dashboard to put its updates.</li> <li>It also passes <code class="language-plaintext highlighter-rouge">table_env</code> (our connection to the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a>), so workers can ask Flink for data.</li> </ul> <p><br></p> <h3 id="2-what-a-worker-does-inside-the-run-method">2. What a Worker Does (Inside the <code class="language-plaintext highlighter-rouge">run</code> method)</h3> <p>Each <code class="language-plaintext highlighter-rouge">WorkerThread</code> class (like <code class="language-plaintext highlighter-rouge">WorkerThread1</code> for game stats or <code class="language-plaintext highlighter-rouge">WorkerThread2</code> for recent moves) inherits from Python’s <code class="language-plaintext highlighter-rouge">Thread</code> class. This allows them to run in the background. The most important part of any worker is its <code class="language-plaintext highlighter-rouge">run</code> method.</p> <p>Let’s look at a simplified <code class="language-plaintext highlighter-rouge">WorkerThread1</code> which updates game statistics:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_worker.py (simplified)
</span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="n">threading</span> <span class="kn">import</span> <span class="n">Thread</span> <span class="c1"># For running tasks in the background
</span><span class="kn">import</span> <span class="n">streamlit</span> <span class="k">as</span> <span class="n">st</span> <span class="c1"># To update the Streamlit UI
</span>
<span class="k">class</span> <span class="nc">WorkerThread1</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Worker thread for displaying game statistics metrics.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">table_env</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>      <span class="c1"># Initial wait time
</span>        <span class="n">self</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>    <span class="c1"># The Streamlit column (e.g., col1) to update
</span>        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span> <span class="o">=</span> <span class="n">table_env</span> <span class="c1"># Our Flink "data scientist" connection
</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Execute the worker thread to display game statistics.</span><span class="sh">"""</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">delay</span><span class="p">)</span> <span class="c1"># Wait a bit before starting (prevents clutter)
</span>
        <span class="c1"># Ask the Flink "data scientist" for the live game stats stream
</span>        <span class="n">stream</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">get_games_stats</span><span class="p">()</span>

        <span class="c1"># Loop forever, getting new data as it comes in from Flink
</span>        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="c1"># Use the target column to display the data
</span>            <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">container</span><span class="p">():</span>
                <span class="n">st</span><span class="p">.</span><span class="nf">metric</span><span class="p">(</span><span class="sh">"</span><span class="s">Active Games</span><span class="sh">"</span><span class="p">,</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Update "Active Games"
</span>                <span class="n">st</span><span class="p">.</span><span class="nf">metric</span><span class="p">(</span><span class="sh">"</span><span class="s">Games Completed Today</span><span class="sh">"</span><span class="p">,</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Update "Games Completed"
</span></code></pre></div></div> <p>In this code:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">class WorkerThread1(Thread):</code> declares this class as a background task.</li> <li> <code class="language-plaintext highlighter-rouge">self.target</code> is the specific placeholder in the Streamlit UI (e.g., <code class="language-plaintext highlighter-rouge">col1.empty()</code>) that this worker will update. <code class="language-plaintext highlighter-rouge">col1.empty()</code> creates an empty container that the worker can fill and re-fill.</li> <li> <code class="language-plaintext highlighter-rouge">self.table_env.get_games_stats()</code> is how this worker asks the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> for the live game statistics. Remember from <a href="07_flink_analytics_engine_.md">Chapter 7</a> that Flink’s <code class="language-plaintext highlighter-rouge">collect()</code> method returns a continuous <code class="language-plaintext highlighter-rouge">stream</code> of results.</li> <li> <code class="language-plaintext highlighter-rouge">for chunk in stream:</code> This loop is crucial! It continuously waits for <em>new</em> data to arrive from Flink. As soon as Flink re-calculates and sends updated stats, this loop gets a <code class="language-plaintext highlighter-rouge">chunk</code> of data.</li> <li> <code class="language-plaintext highlighter-rouge">with self.target.container():</code> ensures that the Streamlit commands (<code class="language-plaintext highlighter-rouge">st.metric</code>) display their content <em>inside</em> the specific column (<code class="language-plaintext highlighter-rouge">col1</code>) assigned to this worker.</li> <li> <code class="language-plaintext highlighter-rouge">st.metric("Active Games", chunk[0])</code> displays a nice, big number (a “metric”) labeled “Active Games” using the first piece of data (<code class="language-plaintext highlighter-rouge">chunk[0]</code>) from Flink.</li> </ul> <p><code class="language-plaintext highlighter-rouge">WorkerThread2</code> works similarly but fetches recent moves and displays them as a table using <code class="language-plaintext highlighter-rouge">st.dataframe</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_worker.py (simplified WorkerThread2)
</span>
<span class="k">class</span> <span class="nc">WorkerThread2</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Worker thread for displaying chess moves data table.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">table_env</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">self</span><span class="p">.</span><span class="n">table_env</span> <span class="o">=</span> <span class="n">table_env</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">delay</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">table_env</span><span class="p">.</span><span class="nf">get_moves</span><span class="p">()</span> <span class="c1"># Get stream of recent moves from Flink
</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="c1"># Display moves data as a scrollable table in the target column
</span>            <span class="n">self</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">container</span><span class="p">().</span><span class="nf">dataframe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">self.table_env.get_moves()</code> asks Flink for the list of recent moves, and <code class="language-plaintext highlighter-rouge">self.target.container().dataframe(chunk, height=400)</code> takes the received <code class="language-plaintext highlighter-rouge">chunk</code> (which is a table of move data) and displays it nicely as a scrollable table within its assigned column (<code class="language-plaintext highlighter-rouge">col2</code>).</p> <p><br></p> <h2 id="internal-workflow-7">Internal Workflow</h2> <p>Let’s visualize how the Live Data Update Workers continuously bring fresh data to your dashboard:</p> <pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant SA as Streamlit App (app.py)
    participant W as Live Data Update Workers (utils_worker.py)
    participant FA as Flink Analytics Engine (TableEnvCustomized)

    User-&gt;&gt;SA: Opens Streamlit Dashboard
    SA-&gt;&gt;W: Calls run_workers() to start Worker Threads
    loop Continuous Dashboard Updates
        W-&gt;&gt;FA: Worker requests latest processed data (e.g., get_games_stats())
        FA--&gt;&gt;W: Flink yields updated results (e.g., (3 active, 2 completed))
        W-&gt;&gt;SA: Worker uses st.metric() or st.dataframe() to update its target section
        SA--&gt;&gt;User: User sees updated numbers/tables on dashboard
    end
</code></pre> <p>In this flow:</p> <ol> <li> <strong>User Opens Dashboard:</strong> You navigate to the Streamlit app in your web browser.</li> <li> <strong>Streamlit App Starts Workers:</strong> The <code class="language-plaintext highlighter-rouge">app.py</code> script runs, sets up the page, and then calls <code class="language-plaintext highlighter-rouge">run_workers</code> to start the background worker threads.</li> <li> <strong>Workers Request Data from Flink:</strong> Each “worker thread” (<code class="language-plaintext highlighter-rouge">WorkerThread1</code>, <code class="language-plaintext highlighter-rouge">WorkerThread2</code>, etc.) continuously asks the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> (via the <code class="language-plaintext highlighter-rouge">table_env</code> object) for the latest processed data related to its specific task.</li> <li> <strong>Flink Provides Data:</strong> The <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> (which is always processing data from Kafka) <code class="language-plaintext highlighter-rouge">yield</code>s (provides) the latest updated results to the waiting workers.</li> <li> <strong>Workers Update Dashboard UI:</strong> Each worker takes the fresh data it received and uses Streamlit commands (<code class="language-plaintext highlighter-rouge">st.metric</code>, <code class="language-plaintext highlighter-rouge">st.dataframe</code>) to update the specific sections of the web page it’s responsible for. Streamlit then re-renders those parts of the page.</li> <li> <strong>User Sees Updates:</strong> You see the numbers and tables on your dashboard change in real-time, reflecting the latest activity across all games!</li> </ol> <p><br></p> <h3 id="the-importance-of-add_script_run_ctx">The Importance of <code class="language-plaintext highlighter-rouge">add_script_run_ctx</code> </h3> <p>There’s one crucial detail when making threads update a Streamlit app. Streamlit usually runs in a single thread. For background threads to be able to tell Streamlit to update the UI, they need a special “permission slip.” This is handled by the <code class="language-plaintext highlighter-rouge">add_script_run_ctx</code> function.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In streamlit/utils/utils_worker.py (simplified run_workers)
</span><span class="kn">from</span> <span class="n">streamlit.runtime.scriptrunner_utils.script_run_context</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_script_run_ctx</span><span class="p">,</span> <span class="n">get_script_run_ctx</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">def</span> <span class="nf">run_workers</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col3</span><span class="p">,</span> <span class="n">col4</span><span class="p">,</span> <span class="n">table_env</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Initialize and start all worker threads for the Streamlit dashboard.</span><span class="sh">"""</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nc">WorkerThread1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">col1</span><span class="p">.</span><span class="nf">empty</span><span class="p">(),</span> <span class="n">table_env</span><span class="p">),</span> <span class="c1"># Stats worker
</span>        <span class="nc">WorkerThread2</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">col2</span><span class="p">.</span><span class="nf">empty</span><span class="p">(),</span> <span class="n">table_env</span><span class="p">),</span> <span class="c1"># Moves worker
</span>        <span class="nc">WorkerThread4</span><span class="p">(</span><span class="mf">1.3</span><span class="p">,</span> <span class="n">col4</span><span class="p">.</span><span class="nf">empty</span><span class="p">()),</span>           <span class="c1"># Timestamp worker
</span>    <span class="p">]</span>

    <span class="c1"># Start all threads
</span>    <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
        <span class="c1"># Crucial: This tells Streamlit that this background thread
</span>        <span class="c1"># is allowed to update the Streamlit page!
</span>        <span class="nf">add_script_run_ctx</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="nf">get_script_run_ctx</span><span class="p">())</span>
        <span class="n">thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="c1"># Wait for all threads to complete (they run forever in this case)
</span>    <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
        <span class="n">thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre></div></div> <p>Here:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">get_script_run_ctx()</code> gets the special “permission slip” from Streamlit’s main thread.</li> <li> <code class="language-plaintext highlighter-rouge">add_script_run_ctx(thread, get_script_run_ctx())</code> then attaches this permission slip to each of our <code class="language-plaintext highlighter-rouge">WorkerThread</code> objects <em>before</em> they start. Without this, Streamlit would not allow the threads to modify the dashboard, and your page would never update!</li> <li> <code class="language-plaintext highlighter-rouge">thread.start()</code> actually begins the execution of the worker’s <code class="language-plaintext highlighter-rouge">run()</code> method in a separate thread.</li> <li> <code class="language-plaintext highlighter-rouge">thread.join()</code> makes the main Streamlit program wait for these threads indefinitely, ensuring the dashboard keeps running and updating.</li> </ul> <p><br></p> <h2 id="conclusion-7">Conclusion</h2> <p>You’ve now learned about the <strong>Live Data Update Workers</strong>! These <code class="language-plaintext highlighter-rouge">WorkerThread</code> classes are the “auto-refresh crew” for our <a href="03_streamlit_analytics_dashboard_.md">Streamlit Analytics Dashboard</a>. They run in separate background threads, continuously fetching the latest analytical results from the <a href="07_flink_analytics_engine_.md">Flink Analytics Engine</a> and using Streamlit commands to update specific sections of the UI. This ensures that our dashboard always displays real-time data without you needing to lift a finger!</p> <p>This concludes our journey through the <code class="language-plaintext highlighter-rouge">kafka-chess</code> project’s architecture! You’ve seen how each component, from the chessboard to the data analytics, plays a vital role in creating a powerful, real-time chess application.</p> <hr> <p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge" rel="external nofollow noopener" target="_blank">AI Codebase Knowledge Builder</a></p> <p><br></p> <h2 id="afterthoughts">Afterthoughts</h2> <p>I took about 3 weeks to complete this project. At the end of this project, I felt satisfied that I had learned a lot: Kafka, ChessboardJS, Flink, Streamlit (multithreading), Pocketflow (to generate the chapters above). I also discovered that it is difficult to setup own Kafka server on-cloud using EC2 as the node frequently disconnected from the controller. The managed Kafka service is also expensive as of now.</p> <p><strong>Lessons Learned</strong></p> <ul> <li>How to setup Kafka server locally</li> <li>How to create a chess web app</li> <li>How does Kafka works</li> <li>How to setup Flink to connect to Kafka</li> <li>How to create a real-time application using Streamlit</li> <li>How to generate tutorials using Pocketflow</li> </ul> <p><strong>Future Enhancements</strong></p> <ul> <li>Update the interactive chessboard app AI to be based on machine learning instead of random</li> <li>Add online learning for the chessboard AI</li> </ul> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Vincent Cheng Yun Sheng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?3e7054dc4d3e3dd8f0731a48453e618e"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?3577194613afa04501eb52f8f4164de9" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>